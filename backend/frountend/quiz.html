<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cialloï½(âˆ ãƒ»Ï‰< )âŒ’â˜…</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, 'Noto Sans', sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol', 'Noto Color Emoji';
            background-color: #f0f2f5; /* æ·¡ç°è‰²èƒŒæ™¯ */
        }
        .quiz-container {
            max-width: 600px;
            margin: 20px auto;
            padding: 20px;
            background-color: white;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }
        .question-card {
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 20px;
            background-color: #ffffff;
        }
        .option-label {
            display: block;
            padding: 12px 16px;
            margin-bottom: 10px;
            border: 1px solid #cbd5e1;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.2s, border-color 0.2s;
        }
        .option-label:hover {
            background-color: #f7fafc;
        }
        .option-label.selected {
            background-color: #ebf8ff; /* æµ…è“è‰²èƒŒæ™¯ */
            border-color: #4299e1; /* è“è‰²è¾¹æ¡† */
        }
        .option-label.correct {
            background-color: #c6f6d5; /* æµ…ç»¿è‰² */
            border-color: #38a169; /* ç»¿è‰² */
        }
        .option-label.incorrect {
            background-color: #fed7d7; /* æµ…çº¢è‰² */
            border-color: #e53e3e; /* çº¢è‰² */
        }
        .btn {
            padding: 10px 20px;
            border-radius: 8px;
            font-weight: 600;
            transition: background-color 0.2s;
            cursor: pointer;
            text-align: center;
        }
        .btn-primary {
            background-color: #4299e1; /* è“è‰² */
            color: white;
        }
        .btn-primary:hover {
            background-color: #2b6cb0; /* æ·±è“è‰² */
        }
        .btn-secondary {
            background-color: #48bb78; /* ç»¿è‰² */
            color: white;
        }
        .btn-secondary:hover {
            background-color: #38a169; /* æ·±ç»¿è‰² */
        }
        .btn-danger {
            background-color: #e53e3e; /* çº¢è‰² */
            color: white;
        }
        .btn-danger:hover {
            background-color: #c53030; /* æ·±çº¢è‰² */
        }
        .feedback-message {
            padding: 12px;
            border-radius: 8px;
            margin-top: 15px;
            font-weight: 500;
        }
        .feedback-correct {
            background-color: #c6f6d5;
            color: #2f855a;
        }
        .feedback-incorrect {
            background-color: #fed7d7;
            color: #c53030;
        }
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(255, 255, 255, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 9999;
        }
        .spinner {
            border: 4px solid rgba(0, 0, 0, 0.1);
            width: 36px;
            height: 36px;
            border-radius: 50%;
            border-left-color: #4299e1;
            animation: spin 1s ease infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div id="app" class="quiz-container">
        <div v-if="isLoading" class="loading-overlay">
            <div class="spinner"></div>
        </div>

        <!-- <h1 class="text-2xl font-bold text-center mb-6 text-gray-700">Cialloï½(âˆ ãƒ»Ï‰< )âŒ’â˜…</h1> -->

        <div v-if="errorMessage" class="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded relative mb-4" role="alert">
            <strong class="font-bold">å‘ç”Ÿé”™è¯¯ï¼š</strong>
            <span class="block sm:inline">{{ errorMessage }}</span>
        </div>

        <div v-if="quizState === 'initial'">
            <button @click="startQuiz" class="btn btn-primary w-full">å¼€å§‹ç­”é¢˜</button>
        </div>

        <div v-if="currentQuestion && (quizState === 'inProgress' || quizState === 'showAnswer')">
            <div class="question-card">
                <div class="flex justify-between items-center mb-3">
                    <span class="text-sm font-semibold text-blue-600">{{ currentQuestion.question_type }}</span>
                    <span class="text-sm text-gray-500">ç¬¬ {{ currentQuestion.display_question_number }} / {{ totalQuestions }} é¢˜</span>
                </div>
                <p class="text-lg text-gray-800 mb-4" v-html="formatQuestionText(currentQuestion.question_text)"></p>
                
                <div v-if="currentQuestion.options" :key="currentQuestion.display_question_number + '-' + currentQuestion.question_type">
                    <div v-for="(optionText, optionKey) in sortedOptions" :key="optionKey">
                        <label :class="getOptionLabelClass(optionKey)" class="option-label">
                            <input 
                                :type="currentQuestion.question_type === 'å•é€‰é¢˜' ? 'radio' : 'checkbox'"
                                :name="'question_' + currentQuestion.display_question_number"
                                :value="optionKey"
                                v-model="selectedAnswers"
                                :disabled="quizState === 'showAnswer'"
                                class="mr-3 align-middle"
                            >
                            <span class="align-middle">{{ optionKey }}. {{ optionText }}</span>
                        </label>
                    </div>
                </div>
            </div>

            <div v-if="feedbackMessage && quizState === 'showAnswer'" 
                 :class="isCurrentAnswerCorrect ? 'feedback-correct' : 'feedback-incorrect'"
                 class="feedback-message mb-4"
                 v-html="feedbackMessage">
            </div>

            <button v-if="quizState === 'inProgress'" @click="submitAnswer" class="btn btn-primary w-full mb-3">æäº¤ç­”æ¡ˆ</button>
            <button v-if="quizState === 'showAnswer' && !isQuizCompleted" @click="nextQuestion" class="btn btn-secondary w-full mb-3">ä¸‹ä¸€é¢˜</button>
            <button v-if="quizState === 'showAnswer' && isQuizCompleted" @click="viewResults" class="btn btn-primary w-full">æŸ¥çœ‹ç»“æœ</button>
        </div>

        <div v-if="quizState === 'completed'">
            <h2 class="text-xl font-semibold text-center text-green-600 mb-4">  æ­å–œæ‚¨ï¼Œç­”é¢˜å®Œæˆï¼ ğŸ‰</h2>
            <p class="text-center text-gray-700 mb-2">æ€»å…±å›ç­”äº† {{ finalResults.total_attempted }} é“é¢˜ã€‚</p>
            <p class="text-center text-gray-700 mb-2">ç­”å¯¹äº† {{ finalResults.total_correct }} é“é¢˜ã€‚</p>
            <p class="text-center text-gray-700 mb-4">ç­”é”™äº† {{ finalResults.total_attempted - finalResults.total_correct }} é“é¢˜ã€‚</p>
            
            <div v-if="finalResults.wrongly_answered && finalResults.wrongly_answered.length > 0" class="mt-6">
                <h3 class="text-lg font-semibold text-red-600 mb-3">é”™é¢˜å›é¡¾ï¼š</h3>
                <ul>
                    <li v-for="(wrongQ, index) in finalResults.wrongly_answered" :key="index" class="mb-4 p-3 border border-red-300 rounded-md bg-red-50">
                        <p class="font-medium text-gray-800">({{ wrongQ.display_question_number }}) {{ wrongQ.question_text }}</p>
                        <p class="text-sm text-red-700">æ­£ç¡®ç­”æ¡ˆ: {{ wrongQ.correct_answer }}</p>
                        <p class="text-sm text-gray-600">ä½ çš„ç­”æ¡ˆ: (å‰ç«¯æœªè®°å½•ï¼Œè¯·è‡ªè¡Œå›å¿†æˆ–åœ¨åç«¯å¢å¼º)</p>
                    </li>
                </ul>
            </div>
             <button @click="restartQuiz" class="btn btn-primary w-full mt-6">å†æ¥ä¸€æ¬¡</button>
        </div>

    </div>

    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <script>
        const { createApp, ref, computed, onMounted } = Vue;

        createApp({
            setup() {
                const userId = ref(null);
                const currentQuestion = ref(null);
                const totalQuestions = ref(0);
                const selectedAnswers = ref([]); // ç”¨äºå¤šé€‰é¢˜ï¼Œå•é€‰é¢˜æ—¶ä¼šæ˜¯å­—ç¬¦ä¸²
                const quizState = ref('initial'); // initial, inProgress, showAnswer, completed
                const feedbackMessage = ref('');
                const isCurrentAnswerCorrect = ref(false);
                const isQuizCompleted = ref(false);
                const finalResults = ref({});
                const isLoading = ref(false);
                const errorMessage = ref('');
                const _nextQuestionData = ref(null); // Stores the next question data

                // å½“éƒ¨ç½²åˆ°åŒä¸€æœåŠ¡å™¨æ—¶ï¼ŒAPI_BASE_URL å¯ä»¥æ˜¯ç›¸å¯¹è·¯å¾„æˆ–ç©ºå­—ç¬¦ä¸²
                // å¦‚æœ Nginx å°† /quiz/* ç›´æ¥ä»£ç†åˆ°åç«¯ï¼Œåˆ™ä¸ºç©ºå­—ç¬¦ä¸²
                // å¦‚æœ Nginx å°† /api/quiz/* ä»£ç†åˆ°åç«¯ï¼Œåˆ™ä¸º '/api'
                const API_BASE_URL = ''; // ä¿®æ”¹ç‚¹ï¼šé€‚é…åŒæœåŠ¡å™¨éƒ¨ç½²

                // å¯¹é€‰é¡¹è¿›è¡Œæ’åº (A, B, C, D, E...)
                const sortedOptions = computed(() => {
                    if (currentQuestion.value && currentQuestion.value.options) {
                        return Object.entries(currentQuestion.value.options)
                            .sort(([keyA], [keyB]) => keyA.localeCompare(keyB))
                            .reduce((obj, [key, value]) => {
                                obj[key] = value;
                                return obj;
                            }, {});
                    }
                    return {};
                });

                const formatQuestionText = (text) => {
                    // ç®€å•æ›¿æ¢æ¢è¡Œç¬¦ä¸º <br>ï¼Œå¯ä»¥æ ¹æ®éœ€è¦æ‰©å±•
                    return text ? text.replace(/\n/g, '<br>') : '';
                };

                const startQuiz = async () => {
                    isLoading.value = true;
                    errorMessage.value = '';
                    try {
                        const response = await fetch(`${API_BASE_URL}/quiz/start`, { method: 'POST' });
                        if (!response.ok) {
                            const errorData = await response.json().catch(() => ({ error: 'æ— æ³•è¿æ¥åˆ°æœåŠ¡å™¨æˆ–æœåŠ¡å™¨è¿”å›é”™è¯¯ã€‚' }));
                            throw new Error(errorData.error || `HTTP error! status: ${response.status}`);
                        }
                        const data = await response.json();
                        userId.value = data.user_id;
                        currentQuestion.value = data.question;
                        totalQuestions.value = data.total_questions;
                        quizState.value = 'inProgress';
                        isQuizCompleted.value = false;
                        resetQuizStateForNewQuestion();
                    } catch (error) {
                        console.error("å¼€å§‹ç­”é¢˜å¤±è´¥:", error);
                        errorMessage.value = `å¼€å§‹ç­”é¢˜å¤±è´¥: ${error.message}`;
                        quizState.value = 'initial'; // å…è®¸ç”¨æˆ·é‡è¯•
                    } finally {
                        isLoading.value = false;
                    }
                };

                const resetQuizStateForNewQuestion = () => {
                    // For single-choice, initialize to null. For multi-choice, initialize to an empty array.
                    if (currentQuestion.value) {
                        selectedAnswers.value = currentQuestion.value.question_type === 'å•é€‰é¢˜' ? null : [];
                    } else {
                        // Fallback if currentQuestion is not yet set, though startQuiz should set it.
                        // Or handle as an error/unexpected state.
                        selectedAnswers.value = null; 
                    }
                    feedbackMessage.value = '';
                    isCurrentAnswerCorrect.value = false;
                };

                const submitAnswer = async () => {
                // The check for selectedAnswers being empty/null for single choice,
                // or an empty array for multiple choice.
                if ((currentQuestion.value?.question_type === 'å•é€‰é¢˜' && selectedAnswers.value === null) ||
                    (currentQuestion.value?.question_type === 'å¤šé€‰é¢˜' && (!selectedAnswers.value || selectedAnswers.value.length === 0))) {
                    alert('è¯·é€‰æ‹©ç­”æ¡ˆåå†æäº¤ï¼');
                    return;
                }

                isLoading.value = true;
                errorMessage.value = '';
                
                let userAnswerString;
                if (currentQuestion.value?.question_type === 'å¤šé€‰é¢˜') {
                    userAnswerString = Array.isArray(selectedAnswers.value) ? [...selectedAnswers.value].sort().join('') : '';
                } else {
                    userAnswerString = selectedAnswers.value;
                }

                isCurrentAnswerCorrect.value = userAnswerString === currentQuestion.value.correct_answer.split('').sort().join('');

                try {
                    const response = await fetch(`${API_BASE_URL}/quiz/answer`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            user_id: userId.value,
                            display_question_number: currentQuestion.value.display_question_number,
                            was_correct: isCurrentAnswerCorrect.value
                        })
                    });

                    if (!response.ok) {
                        const errorData = await response.json().catch(() => ({ error: 'æäº¤ç­”æ¡ˆå¤±è´¥ã€‚' }));
                        throw new Error(errorData.error || `HTTP error! status: ${response.status}`);
                    }
                    const data = await response.json();

                    if (isCurrentAnswerCorrect.value) {
                        feedbackMessage.value = 'å›ç­”æ­£ç¡®ï¼ğŸ‘';
                    } else {
                        feedbackMessage.value = `å›ç­”é”™è¯¯ã€‚æ­£ç¡®ç­”æ¡ˆæ˜¯ï¼š<strong>${currentQuestion.value.correct_answer}</strong>`;
                    }
                    
                    quizState.value = 'showAnswer';
                    _nextQuestionData.value = null; // Reset before setting

                    if (data.quiz_completed) {
                        isQuizCompleted.value = true;
                        if(data.wrong_answers_count !== undefined) {
                            finalResults.value = {
                                total_attempted: data.total_questions_answered,
                                total_correct: data.total_questions_answered - data.wrong_answers_count,
                                wrongly_answered: [] 
                            };
                        }
                    } else if (data.next_question) {
                        // Store next question data instead of directly updating currentQuestion
                        _nextQuestionData.value = data.next_question;
                        isQuizCompleted.value = false; 
                    } else {
                        errorMessage.value = "æ”¶åˆ°æœåŠ¡å™¨å“åº”ï¼Œä½†æ²¡æœ‰ä¸‹ä¸€é¢˜ä¿¡æ¯ä¹Ÿæœªå®Œæˆã€‚";
                        isQuizCompleted.value = true; 
                    }

                } catch (error) {
                    console.error("æäº¤ç­”æ¡ˆå¤±è´¥:", error);
                    errorMessage.value = `æäº¤ç­”æ¡ˆå¤±è´¥: ${error.message}`;
                    quizState.value = 'inProgress'; 
                } finally {
                    isLoading.value = false;
                }
            };

            const nextQuestion = () => {
                if (isQuizCompleted.value) {
                    viewResults();
                    return;
                }

                if (_nextQuestionData.value) {
                    currentQuestion.value = _nextQuestionData.value;
                    _nextQuestionData.value = null; // Clear after use
                    quizState.value = 'inProgress';
                    resetQuizStateForNewQuestion();
                } else {
                    // This case should ideally not be reached if the backend always provides
                    // next_question when quiz is not completed, or if submitAnswer correctly
                    // sets isQuizCompleted to true if no next_question is available.
                    console.error("nextQuestion called, but _nextQuestionData is null and quiz is not completed.");
                    errorMessage.value = "æ— æ³•åŠ è½½ä¸‹ä¸€é¢˜ï¼šæœªè·å–åˆ°ä¸‹ä¸€é¢˜çš„æ•°æ®ã€‚";
                    // Optionally, you could force viewResults() or handle this error state further.
                }
            };
                
                const viewResults = async () => {
                    isLoading.value = true;
                    errorMessage.value = '';
                    try {
                        const response = await fetch(`${API_BASE_URL}/quiz/results?user_id=${userId.value}`);
                        if (!response.ok) {
                            const errorData = await response.json().catch(() => ({ error: 'è·å–ç»“æœå¤±è´¥ã€‚' }));
                            throw new Error(errorData.error || `HTTP error! status: ${response.status}`);
                        }
                        const data = await response.json();
                        finalResults.value = data;
                        quizState.value = 'completed';
                    } catch (error)
                    {
                        console.error("æŸ¥çœ‹ç»“æœå¤±è´¥:", error);
                        errorMessage.value = `æŸ¥çœ‹ç»“æœå¤±è´¥: ${error.message}`;
                    } finally {
                        isLoading.value = false;
                    }
                };

                const getOptionLabelClass = (optionKey) => {
                    const classes = [];
                    if (quizState.value === 'showAnswer') {
                        const correctAnswerKeys = currentQuestion.value.correct_answer.split('');
                        if (correctAnswerKeys.includes(optionKey)) {
                            classes.push('correct');
                        } else {
                            if (currentQuestion.value.question_type === 'å¤šé€‰é¢˜' && selectedAnswers.value.includes(optionKey)) {
                                classes.push('incorrect');
                            }
                            else if (currentQuestion.value.question_type === 'å•é€‰é¢˜' && selectedAnswers.value === optionKey) {
                                 classes.push('incorrect');
                            }
                        }
                    } else { 
                        if (currentQuestion.value.question_type === 'å¤šé€‰é¢˜' && selectedAnswers.value.includes(optionKey)) {
                            classes.push('selected');
                        } else if (currentQuestion.value.question_type === 'å•é€‰é¢˜' && selectedAnswers.value === optionKey) {
                            classes.push('selected');
                        }
                    }
                    return classes.join(' ');
                };

                const restartQuiz = () => {
                    userId.value = null;
                    currentQuestion.value = null;
                    totalQuestions.value = 0;
                    selectedAnswers.value = []; // Reset to empty array, startQuiz/nextQuestion will set specific type
                    quizState.value = 'initial';
                    feedbackMessage.value = '';
                    isCurrentAnswerCorrect.value = false;
                    isQuizCompleted.value = false;
                    finalResults.value = {};
                    errorMessage.value = '';
                };

                return {
                    userId,
                    currentQuestion,
                    totalQuestions,
                    selectedAnswers,
                    quizState,
                    feedbackMessage,
                    isCurrentAnswerCorrect,
                    isQuizCompleted,
                    finalResults,
                    isLoading,
                    errorMessage,
                    // _nextQuestionData, // Not strictly needed in return unless debugging from template
                    startQuiz,
                    submitAnswer,
                    nextQuestion,
                    viewResults,
                    getOptionLabelClass,
                    sortedOptions,
                    formatQuestionText,
                    restartQuiz
                };
            }
        }).mount('#app');
    </script>
</body>
</html>
 
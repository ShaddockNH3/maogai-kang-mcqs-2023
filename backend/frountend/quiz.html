<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ciallo～(∠・ω< )⌒★</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, 'Noto Sans', sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol', 'Noto Color Emoji';
            background-color: #f0f2f5; /* 淡灰色背景 */
        }
        .quiz-container {
            max-width: 600px;
            margin: 20px auto;
            padding: 20px;
            background-color: white;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }
        .question-card {
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 20px;
            background-color: #ffffff;
        }
        .option-label {
            display: block;
            padding: 12px 16px;
            margin-bottom: 10px;
            border: 1px solid #cbd5e1;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.2s, border-color 0.2s;
        }
        .option-label:hover {
            background-color: #f7fafc;
        }
        .option-label.selected {
            background-color: #ebf8ff; /* 浅蓝色背景 */
            border-color: #4299e1; /* 蓝色边框 */
        }
        .option-label.correct {
            background-color: #c6f6d5; /* 浅绿色 */
            border-color: #38a169; /* 绿色 */
        }
        .option-label.incorrect {
            background-color: #fed7d7; /* 浅红色 */
            border-color: #e53e3e; /* 红色 */
        }
        .btn {
            padding: 10px 20px;
            border-radius: 8px;
            font-weight: 600;
            transition: background-color 0.2s;
            cursor: pointer;
            text-align: center;
        }
        .btn-primary {
            background-color: #4299e1; /* 蓝色 */
            color: white;
        }
        .btn-primary:hover {
            background-color: #2b6cb0; /* 深蓝色 */
        }
        .btn-secondary {
            background-color: #48bb78; /* 绿色 */
            color: white;
        }
        .btn-secondary:hover {
            background-color: #38a169; /* 深绿色 */
        }
        .btn-danger {
            background-color: #e53e3e; /* 红色 */
            color: white;
        }
        .btn-danger:hover {
            background-color: #c53030; /* 深红色 */
        }
        .feedback-message {
            padding: 12px;
            border-radius: 8px;
            margin-top: 15px;
            font-weight: 500;
        }
        .feedback-correct {
            background-color: #c6f6d5;
            color: #2f855a;
        }
        .feedback-incorrect {
            background-color: #fed7d7;
            color: #c53030;
        }
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(255, 255, 255, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 9999;
        }
        .spinner {
            border: 4px solid rgba(0, 0, 0, 0.1);
            width: 36px;
            height: 36px;
            border-radius: 50%;
            border-left-color: #4299e1;
            animation: spin 1s ease infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div id="app" class="quiz-container">
        <div v-if="isLoading" class="loading-overlay">
            <div class="spinner"></div>
        </div>

        <!-- <h1 class="text-2xl font-bold text-center mb-6 text-gray-700">Ciallo～(∠・ω< )⌒★</h1> -->

        <div v-if="errorMessage" class="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded relative mb-4" role="alert">
            <strong class="font-bold">发生错误：</strong>
            <span class="block sm:inline">{{ errorMessage }}</span>
        </div>

        <div v-if="quizState === 'initial'">
            <button @click="startQuiz" class="btn btn-primary w-full">开始答题</button>
        </div>

        <div v-if="currentQuestion && (quizState === 'inProgress' || quizState === 'showAnswer')">
            <div class="question-card">
                <div class="flex justify-between items-center mb-3">
                    <span class="text-sm font-semibold text-blue-600">{{ currentQuestion.question_type }}</span>
                    <span class="text-sm text-gray-500">第 {{ currentQuestion.display_question_number }} / {{ totalQuestions }} 题</span>
                </div>
                <p class="text-lg text-gray-800 mb-4" v-html="formatQuestionText(currentQuestion.question_text)"></p>
                
                <div v-if="currentQuestion.options" :key="currentQuestion.display_question_number + '-' + currentQuestion.question_type">
                    <div v-for="(optionText, optionKey) in sortedOptions" :key="optionKey">
                        <label :class="getOptionLabelClass(optionKey)" class="option-label">
                            <input 
                                :type="currentQuestion.question_type === '单选题' ? 'radio' : 'checkbox'"
                                :name="'question_' + currentQuestion.display_question_number"
                                :value="optionKey"
                                v-model="selectedAnswers"
                                :disabled="quizState === 'showAnswer'"
                                class="mr-3 align-middle"
                            >
                            <span class="align-middle">{{ optionKey }}. {{ optionText }}</span>
                        </label>
                    </div>
                </div>
            </div>

            <div v-if="feedbackMessage && quizState === 'showAnswer'" 
                 :class="isCurrentAnswerCorrect ? 'feedback-correct' : 'feedback-incorrect'"
                 class="feedback-message mb-4"
                 v-html="feedbackMessage">
            </div>

            <button v-if="quizState === 'inProgress'" @click="submitAnswer" class="btn btn-primary w-full mb-3">提交答案</button>
            <button v-if="quizState === 'showAnswer' && !isQuizCompleted" @click="nextQuestion" class="btn btn-secondary w-full mb-3">下一题</button>
            <button v-if="quizState === 'showAnswer' && isQuizCompleted" @click="viewResults" class="btn btn-primary w-full">查看结果</button>
        </div>

        <div v-if="quizState === 'completed'">
            <h2 class="text-xl font-semibold text-center text-green-600 mb-4">  恭喜您，答题完成！ 🎉</h2>
            <p class="text-center text-gray-700 mb-2">总共回答了 {{ finalResults.total_attempted }} 道题。</p>
            <p class="text-center text-gray-700 mb-2">答对了 {{ finalResults.total_correct }} 道题。</p>
            <p class="text-center text-gray-700 mb-4">答错了 {{ finalResults.total_attempted - finalResults.total_correct }} 道题。</p>
            
            <div v-if="finalResults.wrongly_answered && finalResults.wrongly_answered.length > 0" class="mt-6">
                <h3 class="text-lg font-semibold text-red-600 mb-3">错题回顾：</h3>
                <ul>
                    <li v-for="(wrongQ, index) in finalResults.wrongly_answered" :key="index" class="mb-4 p-3 border border-red-300 rounded-md bg-red-50">
                        <p class="font-medium text-gray-800">({{ wrongQ.display_question_number }}) {{ wrongQ.question_text }}</p>
                        <p class="text-sm text-red-700">正确答案: {{ wrongQ.correct_answer }}</p>
                        <p class="text-sm text-gray-600">你的答案: (前端未记录，请自行回忆或在后端增强)</p>
                    </li>
                </ul>
            </div>
             <button @click="restartQuiz" class="btn btn-primary w-full mt-6">再来一次</button>
        </div>

    </div>

    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <script>
        const { createApp, ref, computed, onMounted } = Vue;

        createApp({
            setup() {
                const userId = ref(null);
                const currentQuestion = ref(null);
                const totalQuestions = ref(0);
                const selectedAnswers = ref([]); // 用于多选题，单选题时会是字符串
                const quizState = ref('initial'); // initial, inProgress, showAnswer, completed
                const feedbackMessage = ref('');
                const isCurrentAnswerCorrect = ref(false);
                const isQuizCompleted = ref(false);
                const finalResults = ref({});
                const isLoading = ref(false);
                const errorMessage = ref('');
                const _nextQuestionData = ref(null); // Stores the next question data

                // 当部署到同一服务器时，API_BASE_URL 可以是相对路径或空字符串
                // 如果 Nginx 将 /quiz/* 直接代理到后端，则为空字符串
                // 如果 Nginx 将 /api/quiz/* 代理到后端，则为 '/api'
                const API_BASE_URL = ''; // 修改点：适配同服务器部署

                // 对选项进行排序 (A, B, C, D, E...)
                const sortedOptions = computed(() => {
                    if (currentQuestion.value && currentQuestion.value.options) {
                        return Object.entries(currentQuestion.value.options)
                            .sort(([keyA], [keyB]) => keyA.localeCompare(keyB))
                            .reduce((obj, [key, value]) => {
                                obj[key] = value;
                                return obj;
                            }, {});
                    }
                    return {};
                });

                const formatQuestionText = (text) => {
                    // 简单替换换行符为 <br>，可以根据需要扩展
                    return text ? text.replace(/\n/g, '<br>') : '';
                };

                const startQuiz = async () => {
                    isLoading.value = true;
                    errorMessage.value = '';
                    try {
                        const response = await fetch(`${API_BASE_URL}/quiz/start`, { method: 'POST' });
                        if (!response.ok) {
                            const errorData = await response.json().catch(() => ({ error: '无法连接到服务器或服务器返回错误。' }));
                            throw new Error(errorData.error || `HTTP error! status: ${response.status}`);
                        }
                        const data = await response.json();
                        userId.value = data.user_id;
                        currentQuestion.value = data.question;
                        totalQuestions.value = data.total_questions;
                        quizState.value = 'inProgress';
                        isQuizCompleted.value = false;
                        resetQuizStateForNewQuestion();
                    } catch (error) {
                        console.error("开始答题失败:", error);
                        errorMessage.value = `开始答题失败: ${error.message}`;
                        quizState.value = 'initial'; // 允许用户重试
                    } finally {
                        isLoading.value = false;
                    }
                };

                const resetQuizStateForNewQuestion = () => {
                    // For single-choice, initialize to null. For multi-choice, initialize to an empty array.
                    if (currentQuestion.value) {
                        selectedAnswers.value = currentQuestion.value.question_type === '单选题' ? null : [];
                    } else {
                        // Fallback if currentQuestion is not yet set, though startQuiz should set it.
                        // Or handle as an error/unexpected state.
                        selectedAnswers.value = null; 
                    }
                    feedbackMessage.value = '';
                    isCurrentAnswerCorrect.value = false;
                };

                const submitAnswer = async () => {
                // The check for selectedAnswers being empty/null for single choice,
                // or an empty array for multiple choice.
                if ((currentQuestion.value?.question_type === '单选题' && selectedAnswers.value === null) ||
                    (currentQuestion.value?.question_type === '多选题' && (!selectedAnswers.value || selectedAnswers.value.length === 0))) {
                    alert('请选择答案后再提交！');
                    return;
                }

                isLoading.value = true;
                errorMessage.value = '';
                
                let userAnswerString;
                if (currentQuestion.value?.question_type === '多选题') {
                    userAnswerString = Array.isArray(selectedAnswers.value) ? [...selectedAnswers.value].sort().join('') : '';
                } else {
                    userAnswerString = selectedAnswers.value;
                }

                isCurrentAnswerCorrect.value = userAnswerString === currentQuestion.value.correct_answer.split('').sort().join('');

                try {
                    const response = await fetch(`${API_BASE_URL}/quiz/answer`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            user_id: userId.value,
                            display_question_number: currentQuestion.value.display_question_number,
                            was_correct: isCurrentAnswerCorrect.value
                        })
                    });

                    if (!response.ok) {
                        const errorData = await response.json().catch(() => ({ error: '提交答案失败。' }));
                        throw new Error(errorData.error || `HTTP error! status: ${response.status}`);
                    }
                    const data = await response.json();

                    if (isCurrentAnswerCorrect.value) {
                        feedbackMessage.value = '回答正确！👍';
                    } else {
                        feedbackMessage.value = `回答错误。正确答案是：<strong>${currentQuestion.value.correct_answer}</strong>`;
                    }
                    
                    quizState.value = 'showAnswer';
                    _nextQuestionData.value = null; // Reset before setting

                    if (data.quiz_completed) {
                        isQuizCompleted.value = true;
                        if(data.wrong_answers_count !== undefined) {
                            finalResults.value = {
                                total_attempted: data.total_questions_answered,
                                total_correct: data.total_questions_answered - data.wrong_answers_count,
                                wrongly_answered: [] 
                            };
                        }
                    } else if (data.next_question) {
                        // Store next question data instead of directly updating currentQuestion
                        _nextQuestionData.value = data.next_question;
                        isQuizCompleted.value = false; 
                    } else {
                        errorMessage.value = "收到服务器响应，但没有下一题信息也未完成。";
                        isQuizCompleted.value = true; 
                    }

                } catch (error) {
                    console.error("提交答案失败:", error);
                    errorMessage.value = `提交答案失败: ${error.message}`;
                    quizState.value = 'inProgress'; 
                } finally {
                    isLoading.value = false;
                }
            };

            const nextQuestion = () => {
                if (isQuizCompleted.value) {
                    viewResults();
                    return;
                }

                if (_nextQuestionData.value) {
                    currentQuestion.value = _nextQuestionData.value;
                    _nextQuestionData.value = null; // Clear after use
                    quizState.value = 'inProgress';
                    resetQuizStateForNewQuestion();
                } else {
                    // This case should ideally not be reached if the backend always provides
                    // next_question when quiz is not completed, or if submitAnswer correctly
                    // sets isQuizCompleted to true if no next_question is available.
                    console.error("nextQuestion called, but _nextQuestionData is null and quiz is not completed.");
                    errorMessage.value = "无法加载下一题：未获取到下一题的数据。";
                    // Optionally, you could force viewResults() or handle this error state further.
                }
            };
                
                const viewResults = async () => {
                    isLoading.value = true;
                    errorMessage.value = '';
                    try {
                        const response = await fetch(`${API_BASE_URL}/quiz/results?user_id=${userId.value}`);
                        if (!response.ok) {
                            const errorData = await response.json().catch(() => ({ error: '获取结果失败。' }));
                            throw new Error(errorData.error || `HTTP error! status: ${response.status}`);
                        }
                        const data = await response.json();
                        finalResults.value = data;
                        quizState.value = 'completed';
                    } catch (error)
                    {
                        console.error("查看结果失败:", error);
                        errorMessage.value = `查看结果失败: ${error.message}`;
                    } finally {
                        isLoading.value = false;
                    }
                };

                const getOptionLabelClass = (optionKey) => {
                    const classes = [];
                    if (quizState.value === 'showAnswer') {
                        const correctAnswerKeys = currentQuestion.value.correct_answer.split('');
                        if (correctAnswerKeys.includes(optionKey)) {
                            classes.push('correct');
                        } else {
                            if (currentQuestion.value.question_type === '多选题' && selectedAnswers.value.includes(optionKey)) {
                                classes.push('incorrect');
                            }
                            else if (currentQuestion.value.question_type === '单选题' && selectedAnswers.value === optionKey) {
                                 classes.push('incorrect');
                            }
                        }
                    } else { 
                        if (currentQuestion.value.question_type === '多选题' && selectedAnswers.value.includes(optionKey)) {
                            classes.push('selected');
                        } else if (currentQuestion.value.question_type === '单选题' && selectedAnswers.value === optionKey) {
                            classes.push('selected');
                        }
                    }
                    return classes.join(' ');
                };

                const restartQuiz = () => {
                    userId.value = null;
                    currentQuestion.value = null;
                    totalQuestions.value = 0;
                    selectedAnswers.value = []; // Reset to empty array, startQuiz/nextQuestion will set specific type
                    quizState.value = 'initial';
                    feedbackMessage.value = '';
                    isCurrentAnswerCorrect.value = false;
                    isQuizCompleted.value = false;
                    finalResults.value = {};
                    errorMessage.value = '';
                };

                return {
                    userId,
                    currentQuestion,
                    totalQuestions,
                    selectedAnswers,
                    quizState,
                    feedbackMessage,
                    isCurrentAnswerCorrect,
                    isQuizCompleted,
                    finalResults,
                    isLoading,
                    errorMessage,
                    // _nextQuestionData, // Not strictly needed in return unless debugging from template
                    startQuiz,
                    submitAnswer,
                    nextQuestion,
                    viewResults,
                    getOptionLabelClass,
                    sortedOptions,
                    formatQuestionText,
                    restartQuiz
                };
            }
        }).mount('#app');
    </script>
</body>
</html>
 
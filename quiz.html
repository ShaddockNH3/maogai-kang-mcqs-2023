<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å–µå–µå­¦ä¹ å°åŠ©æ‰‹</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <style>
        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, 'Noto Sans', sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol', 'Noto Color Emoji';
            background-color: #f0f2f5;
            margin: 0; 
            padding: 0; 
            display: flex; /* Added for centering the app container */
            justify-content: center; /* Added for centering the app container */
            align-items: flex-start; /* Align to top */
            min-height: 100vh; /* Ensure body takes full viewport height */
        }
        .app-container {
            max-width: 700px; 
            width: 100%; 
            /* margin: 0 auto; Removed to rely on body flex for centering */
            padding: 10px; 
            background-color: white;
            min-height: 100vh; /* Ensure app container can take full height if needed */
            box-sizing: border-box;
            box-shadow: 0 0 15px rgba(0,0,0,0.1); /* Optional: add some shadow */
        }
        .btn {
            display: inline-block;
            padding: 8px 12px;
            margin-left: 8px;
            border-radius: 6px;
            font-weight: 500;
            transition: background-color 0.2s;
            cursor: pointer;
            text-align: center;
            border: 1px solid transparent;
            font-size: 0.875rem; /* text-sm */
            line-height: 1.25rem;
        }
        .btn-full-width {
            display: block;
            width: 100%;
            margin-left: 0;
            margin-bottom: 10px;
            padding: 10px 15px;
        }
        .btn-primary { background-color: #4299e1; color: white; }
        .btn-primary:hover { background-color: #2b6cb0; }
        .btn-secondary { background-color: #48bb78; color: white; }
        .btn-secondary:hover { background-color: #38a169; }
        .btn-warning { background-color: #f6ad55; color: white; }
        .btn-warning:hover { background-color: #dd6b20; }
        .btn-danger { background-color: #e53e3e; color: white; }
        .btn-danger:hover { background-color: #c53030; }
        .btn-info { background-color: #63b3ed; color: white; } /* New style for info/logout */
        .btn-info:hover { background-color: #4299e1; }
        .btn-outline { background-color: white; color: #4a5568; border-color: #cbd5e1; }
        .btn-outline:hover { background-color: #f7fafc; }
        .btn:disabled {
            background-color: #d1d5db;
            color: #6b7280;
            cursor: not-allowed;
            border-color: #d1d5db;
        }

        .question-card { border: 1px solid #e2e8f0; border-radius: 8px; padding: 12px; margin-bottom: 15px; background-color: #ffffff;}
        .option-label { display: block; padding: 10px 12px; margin-bottom: 8px; border: 1px solid #cbd5e1; border-radius: 8px; cursor: pointer; transition: background-color 0.2s, border-color 0.2s; }
        .option-label:hover { background-color: #f7fafc; }
        .option-label.selected { background-color: #ebf8ff; border-color: #4299e1; }
        .option-label.correct { background-color: #c6f6d5; border-color: #38a169; }
        .option-label.incorrect { background-color: #fed7d7; border-color: #e53e3e; }
        
        .feedback-message { padding: 10px; border-radius: 8px; margin-top: 10px; font-weight: 500; min-height: 40px; }
        .feedback-correct { background-color: #c6f6d5; color: #2f855a; }
        .feedback-incorrect { background-color: #fed7d7; color: #c53030; }

        .loading-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(255, 255, 255, 0.8); display: flex; justify-content: center; align-items: center; z-index: 9999; }
        .spinner { border: 4px solid rgba(0, 0, 0, 0.1); width: 36px; height: 36px; border-radius: 50%; border-left-color: #4299e1; animation: spin 1s ease infinite; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        select, input[type="text"], input[type="number"], input[type="password"] {
            padding: 8px 12px; /* Consistent padding */
            margin-bottom: 10px;
            border: 1px solid #cbd5e1;
            border-radius: 6px;
            box-sizing: border-box;
            width: 100%; /* Make inputs full width by default */
        }
        input.jump-input { 
            width: 70px; 
            margin-left: 8px;
            margin-right: 4px;
            text-align: center;
        }
        .chapter-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(100px, 1fr)); gap: 8px; margin-bottom: 15px;}
        .chapter-btn { padding: 8px; border: 1px solid #cbd5e1; border-radius: 6px; text-align: center; cursor: pointer; font-size: 0.875rem; }
        .chapter-btn.active { background-color: #4299e1; color: white; border-color: #4299e1;}

        .nav-bar { display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; padding-bottom: 8px; border-bottom: 1px solid #e2e8f0;}
        .nav-bar .btn-group { display: flex; align-items: center;}
        .nav-bar .btn-group .btn { width: auto; }
        .nav-bar .btn-group input.jump-input { height: 37px; }

        .main-title { font-size: 1.875rem; font-weight: bold; text-align: center; margin-bottom: 1.5rem; color: #4a5568; }
        .question-info-bar { display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.75rem; font-size: 0.875rem; }
        .question-text-area { font-size: 1.125rem; color: #2d3748; margin-bottom: 1rem; line-height: 1.6; }
        
        /* Styles for UserID input view */
        .userid-input-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: calc(100vh - 20px); /* Adjust based on app-container padding */
            padding: 20px;
        }
        .userid-input-box {
            background-color: white;
            padding: 2rem; /* More padding */
            border-radius: 0.5rem; /* 8px */
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05); /* shadow-xl */
            width: 100%;
            max-width: 400px; /* md */
        }
    </style>
</head>
<body>
    <div id="app" class="app-container">
        <div v-if="isLoading" class="loading-overlay">
            <div class="spinner"></div>
        </div>

        <div v-if="errorMessage && !isLoading" class="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded relative mb-4" role="alert">
            <strong class="font-bold">å–µå‘œï¼å‡ºé”™äº†ï¼š</strong>
            <span class="block sm:inline">{{ errorMessage }}</span>
            <button @click="errorMessage = ''" class="absolute top-0 bottom-0 right-0 px-4 py-3">
                <svg class="fill-current h-6 w-6 text-red-500" role="button" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><title>å…³é—­</title><path d="M14.348 14.849a1.2 1.2 0 0 1-1.697 0L10 11.819l-2.651 3.029a1.2 1.2 0 1 1-1.697-1.697l2.758-3.15-2.759-3.152a1.2 1.2 0 1 1 1.697-1.697L10 8.183l2.651-3.031a1.2 1.2 0 1 1 1.697 1.697l-2.758 3.152 2.758 3.15a1.2 1.2 0 0 1 0 1.698z"/></svg>
            </button>
        </div>
        
        <div v-if="!userId && !isLoading" class="userid-input-container">
            <div class="userid-input-box">
                <h1 class="text-2xl font-bold text-center text-gray-700 mb-2">å–µå–µå­¦ä¹ å°åŠ©æ‰‹</h1>
                <p class="text-center text-gray-500 mb-6">è¯·è¾“å…¥æ‚¨çš„ç”¨æˆ·IDç™»å½•æˆ–åˆ›å»ºæ–°è´¦æˆ·ï¼š</p>
                <input type="text" v-model="inputUserId" @keyup.enter="submitUserId" placeholder="ç”¨æˆ·ID (ä¾‹å¦‚ï¼šcatLover123)" class="w-full px-4 py-2 border border-gray-300 rounded-md mb-4 focus:ring-blue-500 focus:border-blue-500">
                <button @click="submitUserId" class="btn btn-primary btn-full-width">ç¡®å®š</button>
                <p v-if="userIdError" class="text-red-500 text-sm mt-2 text-center">{{ userIdError }}</p>
            </div>
        </div>

        <div v-if="userId && !isLoading">
            <div v-if="currentView !== 'mainMenu'" class="nav-bar">
                <button @click="goBackToMenu" class="btn btn-outline">è¿”å›ä¸»èœå•</button>
                
                <div class="btn-group">
                    <template v-if="isInQuestionView && allModeQuestions.length > 0 && (currentView === 'quizMode' || quizModeState === 'inProgress')">
                        <button @click="toggleJumpInput" class="btn btn-outline">è·³è½¬</button>
                        <input v-if="showJumpInput" type="number" v-model.number="jumpToQuestionNumberInput" 
                               min="1" :max="totalQuestions" class="jump-input" placeholder="é¢˜å·" @keyup.enter="jumpToQuestion">
                        <button v-if="showJumpInput" @click="jumpToQuestion" class="btn btn-primary">Go</button>
                        <button @click="previousQuestion" :disabled="currentQuestionIndex === 0" class="btn btn-outline">ä¸Šä¸€é¢˜</button>
                    </template>
                    
                    <template v-if="currentView === 'incorrectReview' && quizModeState === 'showAnswer'">
                        <button @click="previousQuestion" :disabled="currentQuestionIndex === 0" class="btn btn-outline">ä¸Šä¸€é¢˜</button>
                        <button @click="deleteCurrentIncorrectQuestion" class="btn btn-danger">åˆ é™¤æ­¤é¢˜</button>
                    </template>
                </div>
            </div>
            
            <h1 v-if="!isInQuestionView || currentView === 'mainMenu'" class="main-title">
                {{ currentView === 'mainMenu' ? 'å–µå–µå­¦ä¹ å°åŠ©æ‰‹' : viewTitle }}
                 <span v-if="currentView === 'mainMenu' && userId" class="block text-xs text-gray-500 font-normal mt-1">å½“å‰ç”¨æˆ·: {{ userId }}</span>
            </h1>


            <div v-if="currentView === 'mainMenu'">
                <p class="text-center text-gray-600 mb-6">ä¸»äººï¼Œä»Šå¤©æƒ³åšäº›ä»€ä¹ˆå‘¢ï¼Ÿ</p>
                <button @click="selectMode('quickReview')" class="btn btn-primary btn-full-width">1. é€Ÿåˆ·æ¨¡å¼</button>
                <button @click="selectMode('quizMode')" class="btn btn-secondary btn-full-width">2. ç­”é¢˜æ¨¡å¼</button>
                <button @click="selectMode('incorrectReview')" class="btn btn-warning btn-full-width">3. é”™é¢˜å›é¡¾</button>
                <button @click="navigateTo('controlMode')" class="btn btn-danger btn-full-width">4. æ§åˆ¶æ¨¡å¼</button>
            </div>

            <div v-if="currentView === 'chapterOrderSelection'">
                <h2 class="text-xl font-semibold mb-4 text-gray-700">æ¨¡å¼è®¾ç½®ï¼š{{ modeDisplayName }}</h2>
                <div class="mb-6">
                    <label class="block text-gray-700 text-sm font-bold mb-2">é€‰æ‹©ç« èŠ‚ï¼š</label>
                    <div class="chapter-grid">
                        <button v-for="chapter in availableChapters" :key="chapter.value"
                                @click="toggleChapterSelection(chapter.value)"
                                :class="{'active': selectedChapters.includes(chapter.value)}"
                                class="chapter-btn">
                            {{ chapter.text }}
                        </button>
                    </div>
                    <p class="text-xs text-gray-500 mt-1">æç¤ºï¼šé€‰æ‹©â€œå…¨éƒ¨ç« èŠ‚â€ä¼šè‡ªåŠ¨é€‰ä¸­æ‰€æœ‰ç« èŠ‚ã€‚å†æ¬¡ç‚¹å‡»å·²é€‰ç« èŠ‚å¯å–æ¶ˆã€‚</p>
                </div>
                <div class="mb-6" v-if="activeMode !== 'incorrectReview'">
                    <label class="block text-gray-700 text-sm font-bold mb-2">é¢˜ç›®é¡ºåºï¼š</label>
                    <div class="flex">
                        <label class="mr-4 inline-flex items-center">
                            <input type="radio" class="form-radio mr-1" v-model="selectedOrder" value="sequential">
                            <span class="ml-2">æ­£åº</span>
                        </label>
                        <label class="inline-flex items-center">
                            <input type="radio" class="form-radio mr-1" v-model="selectedOrder" value="random">
                            <span class="ml-2">éšæœº</span>
                        </label>
                    </div>
                </div>
                <button @click="startSelectedMode" class="btn btn-primary btn-full-width" 
                        :disabled="activeMode !== 'incorrectReview' && selectedChapters.length === 0">
                    å¼€å§‹ {{ modeDisplayName }}
                </button>
            </div>

            <div v-if="currentQuestion && isInQuestionView">
                <div class="question-card">
                    <div class="question-info-bar">
                        <span class="font-semibold text-blue-600">{{ currentQuestion.question_type }}</span>
                        <span class="text-gray-500">
                            ç¬¬ {{ currentQuestionIndex + 1 }} / {{ totalQuestions }} é¢˜
                            <span v-if="currentQuestion.original_question_number">
                                (åŸ: {{ currentQuestion.original_question_number }} @ {{ currentQuestion.original_chapter }})
                            </span>
                        </span>
                    </div>
                    <p class="question-text-area" v-html="formatQuestionText(currentQuestion.question_text)"></p>
                    <div v-if="currentQuestion.options" :key="currentQuestion.quiz_question_id + '-' + currentQuestion.question_type">
                        <div v-for="(optionText, optionKey) in sortedOptions" :key="optionKey">
                            <label :class="getOptionLabelClass(optionKey)" class="option-label">
                                <input 
                                    :type="currentQuestion.question_type === 'å•é€‰é¢˜' ? 'radio' : 'checkbox'"
                                    :name="'question_option_' + currentQuestion.quiz_question_id"
                                    :value="optionKey"
                                    v-model="selectedAnswers"
                                    :disabled="quizModeState === 'showAnswer' || currentView === 'quickReview'"
                                    class="mr-3 align-middle"
                                >
                                <span class="align-middle">{{ optionKey }}. {{ optionText }}</span>
                            </label>
                        </div>
                    </div>
                    <div v-if="currentView === 'quickReview' && currentQuestion.correct_answer" 
                         class="mt-3 p-2 bg-green-50 border border-green-200 rounded text-sm">
                        <p class="font-semibold text-green-700">æ­£ç¡®ç­”æ¡ˆï¼š {{ currentQuestion.correct_answer }}</p>
                    </div>
                </div>
                <div v-if="(currentView === 'quizMode' || currentView === 'incorrectReview') && feedbackMessage && quizModeState === 'showAnswer'" 
                     :class="isCurrentAnswerCorrect ? 'feedback-correct' : 'feedback-incorrect'"
                     class="feedback-message mb-3"
                     v-html="feedbackMessage">
                </div>
                <div class="mt-3">
                    <button v-if="(currentView === 'quizMode' || currentView === 'incorrectReview') && quizModeState === 'inProgress'" 
                            @click="submitAnswerForMode" class="btn btn-primary btn-full-width">
                        æäº¤ç­”æ¡ˆ
                    </button>
                    <button v-if="showNextButton" 
                            @click="fetchNextQuestion" class="btn btn-secondary btn-full-width">
                        ä¸‹ä¸€é¢˜
                    </button>
                    <button v-if="isQuizCompleted && isInQuestionView" 
                            @click="navigateTo('resultsView')" class="btn btn-primary btn-full-width">
                        æŸ¥çœ‹æœ¬æ¬¡æ€»ç»“
                    </button>
                </div>
            </div>

            <div v-if="currentView === 'resultsView'">
                <h2 class="text-xl font-semibold text-center text-green-600 mb-4">ğŸ‰ æœ¬è½®{{ modeDisplayName }}å®Œæˆï¼ ğŸ‰</h2>
                <p class="text-center text-gray-700 mb-2">æ€»å…± {{ originalTotalQuestions }} é“é¢˜ã€‚</p>
                <div v-if="activeMode === 'quizMode' || activeMode === 'incorrectReview'">
                    <p class="text-center text-gray-700 mb-2">å›ç­”äº† {{ quizResults.total_answered }} é“é¢˜ã€‚</p>
                    <p class="text-center text-gray-700 mb-2">ç­”å¯¹äº† {{ quizResults.total_correct }} é“é¢˜ã€‚</p>
                    <p class="text-center text-gray-700 mb-4">ç­”é”™äº† {{ quizResults.total_answered - quizResults.total_correct }} é“é¢˜ã€‚</p>
                </div>
                <button @click="goBackToMenu" class="btn btn-primary btn-full-width mt-6">è¿”å›ä¸»èœå•</button>
            </div>

            <div v-if="currentView === 'controlMode'">
                <p class="text-gray-700 mb-1">å½“å‰ç”¨æˆ·ID: <strong>{{ userId }}</strong></p>
                <p class="text-gray-700 mb-4">åœ¨è¿™é‡Œï¼Œæ‚¨å¯ä»¥ç®¡ç†æ‚¨çš„ç”¨æˆ·æ•°æ®å’Œä¼šè¯ã€‚</p>
                <button @click="confirmClearUserData" class="btn btn-danger btn-full-width">æ¸…ç†å½“å‰ç”¨æˆ·æ•°æ®</button>
                <button @click="logoutCurrentUser" class="btn btn-info btn-full-width mt-2">é€€å‡ºç™»å½• (åˆ‡æ¢ç”¨æˆ·)</button>
            </div>
        </div>
    </div>

    <script>
        const { createApp, ref, computed, onMounted, watch } = Vue;

        createApp({
            setup() {
                const isLoading = ref(false);
                const errorMessage = ref(''); 
                const userIdError = ref(''); 
                const currentView = ref('mainMenu'); 
                const viewTitle = ref('å–µå–µå­¦ä¹ å°åŠ©æ‰‹');
                
                const userId = ref(localStorage.getItem('quizAppUserId') || '');
                const inputUserId = ref(''); 

                const API_BASE_URL = ''; 
                const availableChapters = ref([...Array.from({ length: 9 }, (_, i) => ({ value: i.toString(), text: `ç« èŠ‚ ${i}` })), { value: 'all', text: 'å…¨éƒ¨ç« èŠ‚' }]);
                const selectedChapters = ref([]); 
                const selectedOrder = ref('sequential'); 
                const activeMode = ref(''); 
                const modeDisplayName = ref('');
                
                const allModeQuestions = ref([]); 
                const currentQuestion = ref(null); 
                const currentQuestionIndex = ref(-1); 
                const totalQuestions = ref(0);
                const originalTotalQuestions = ref(0); // Store initial count for results summary
                const isQuizCompleted = ref(false);

                const selectedAnswers = ref([]); 
                const quizModeState = ref('inProgress'); 
                const feedbackMessage = ref('');
                const isCurrentAnswerCorrect = ref(false);
                const quizResults = ref({ total_answered: 0, total_correct: 0 });
                
                const showJumpInput = ref(false);
                const jumpToQuestionNumberInput = ref(null);

                const isInQuestionView = computed(() => {
                    return ['quickReview', 'quizMode', 'incorrectReview'].includes(currentView.value);
                });

                const showNextButton = computed(() => {
                    if (!isInQuestionView.value || isQuizCompleted.value) return false;
                    // In review mode, show next button always if not the last question
                    if (currentView.value === 'quickReview' && currentQuestionIndex.value < totalQuestions.value - 1) return true;
                    // In quiz/incorrect modes, only show after submitting an answer
                    if ((currentView.value === 'quizMode' || currentView.value === 'incorrectReview') && quizModeState.value === 'showAnswer') return true;
                    return false;
                });

                const initializeUserSession = async (idToInit) => {
                    if (!idToInit) {
                        userId.value = ''; 
                        return; 
                    }
                    isLoading.value = true;
                    errorMessage.value = ''; 
                    userIdError.value = ''; 
                    try {
                        const response = await fetch(`${API_BASE_URL}/api/session/init`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ user_id: idToInit })
                        });
                        if (!response.ok) {
                            let errorDetailMessage = `HTTP é”™è¯¯: ${response.status} ${response.statusText}. `;
                            try { const errorBodyText = await response.text(); errorDetailMessage += `æœåŠ¡å™¨è¯¦æƒ…: "${errorBodyText || '(æ— å“åº”ä½“)'}"`; } catch (e) { errorDetailMessage += "æ— æ³•è¯»å–æœåŠ¡å™¨é”™è¯¯å“åº”ã€‚"; }
                            throw new Error(`ç”¨æˆ·ä¼šè¯åˆå§‹åŒ–å¤±è´¥ã€‚${errorDetailMessage}`);
                        }
                        const data = await response.json();
                        if (data.user_id) {
                            userId.value = data.user_id;
                            localStorage.setItem('quizAppUserId', userId.value);
                            inputUserId.value = ''; 
                            console.log(data.is_new_user ? `æ–°ç”¨æˆ· '${userId.value}' ä¼šè¯å·²åˆ›å»ºã€‚` : `ç”¨æˆ· '${userId.value}' ä¼šè¯å·²å»ºç«‹ã€‚`);
                        } else {
                            throw new Error("æœåŠ¡å™¨å“åº”ä¸­æœªæ‰¾åˆ° user_idã€‚");
                        }
                    } catch (err) {
                        if (!userId.value && inputUserId.value) { 
                           userIdError.value = err.message || "åˆå§‹åŒ–ç”¨æˆ·ä¼šè¯æ—¶å‘ç”ŸæœªçŸ¥ç½‘ç»œé”™è¯¯ã€‚è¯·æ£€æŸ¥æ‚¨çš„ç”¨æˆ·IDæˆ–ç½‘ç»œè¿æ¥ã€‚";
                        } else { 
                           errorMessage.value = err.message || "åˆå§‹åŒ–ç”¨æˆ·ä¼šè¯æ—¶å‘ç”ŸæœªçŸ¥ç½‘ç»œé”™è¯¯ã€‚";
                        }
                        userId.value = ''; 
                        localStorage.removeItem('quizAppUserId'); 
                    } finally {
                        isLoading.value = false;
                    }
                };
                
                const submitUserId = async () => {
                    userIdError.value = ''; 
                    if (!inputUserId.value.trim()) {
                        userIdError.value = "ç”¨æˆ·IDä¸èƒ½ä¸ºç©ºï¼Œè¯·è¾“å…¥ä¸€ä¸ªæœ‰æ•ˆçš„IDã€‚";
                        return;
                    }
                    if (inputUserId.value.trim().length < 3 || inputUserId.value.trim().length > 50) {
                        userIdError.value = "ç”¨æˆ·IDé•¿åº¦åº”åœ¨3åˆ°50ä¸ªå­—ç¬¦ä¹‹é—´ã€‚";
                        return;
                    }
                    if (!/^[a-zA-Z0-9_-]+$/.test(inputUserId.value.trim())) {
                        userIdError.value = "ç”¨æˆ·IDåªèƒ½åŒ…å«å­—æ¯ã€æ•°å­—ã€ä¸‹åˆ’çº¿(_)å’Œè¿å­—ç¬¦(-)ã€‚";
                        return;
                    }
                    await initializeUserSession(inputUserId.value.trim());
                };

                onMounted(() => {
                    const storedUserId = localStorage.getItem('quizAppUserId');
                    if (storedUserId) {
                        userId.value = storedUserId; 
                        initializeUserSession(storedUserId); 
                    }
                });

                watch(currentView, (newView) => { 
                    switch(newView) {
                        case 'mainMenu': viewTitle.value = 'å–µå–µå­¦ä¹ å°åŠ©æ‰‹'; break;
                        case 'chapterOrderSelection': viewTitle.value = `æ¨¡å¼è®¾ç½® - ${modeDisplayName.value}`; break;
                        case 'quickReview': viewTitle.value = 'é€Ÿåˆ·æ¨¡å¼'; break;
                        case 'quizMode': viewTitle.value = 'ç­”é¢˜æ¨¡å¼'; break;
                        case 'incorrectReview': viewTitle.value = 'é”™é¢˜å›é¡¾'; break;
                        case 'resultsView': viewTitle.value = 'æœ¬è½®æ€»ç»“'; break;
                        case 'controlMode': viewTitle.value = 'æ§åˆ¶æ¨¡å¼'; break;
                        default: viewTitle.value = 'å–µå–µå­¦ä¹ å°åŠ©æ‰‹';
                    }
                    if (errorMessage.value && (userId.value || newView !== 'mainMenu')) {
                         errorMessage.value = '';
                    }
                    if (!isInQuestionView.value) { 
                        showJumpInput.value = false;
                    }
                });
                
                const navigateTo = (view) => {
                    currentView.value = view;
                };

                const goBackToMenu = () => {
                    resetModeState(); 
                    if (userId.value) { 
                        navigateTo('mainMenu');
                    } else { 
                        inputUserId.value = ''; 
                        userIdError.value = ''; 
                    }
                };

                const resetModeState = () => {
                    allModeQuestions.value = [];
                    currentQuestion.value = null;
                    currentQuestionIndex.value = -1;
                    totalQuestions.value = 0;
                    originalTotalQuestions.value = 0;
                    isQuizCompleted.value = false;
                    selectedAnswers.value = [];
                    feedbackMessage.value = '';
                    quizModeState.value = 'inProgress';
                    quizResults.value = { total_answered: 0, total_correct: 0 };
                    showJumpInput.value = false;
                    jumpToQuestionNumberInput.value = null;
                };
                
                const selectMode = (mode) => { 
                    if (!userId.value) {
                        errorMessage.value = "ç”¨æˆ·IDä¸¢å¤±ï¼Œè¯·é‡æ–°è¾“å…¥ç”¨æˆ·IDæˆ–åˆ·æ–°é¡µé¢ã€‚";
                        return;
                    }
                    activeMode.value = mode; 
                    selectedChapters.value = []; 
                    selectedOrder.value = 'sequential'; 
                    
                    if (mode === 'quickReview') modeDisplayName.value = 'é€Ÿåˆ·æ¨¡å¼';
                    else if (mode === 'quizMode') modeDisplayName.value = 'ç­”é¢˜æ¨¡å¼';
                    else if (mode === 'incorrectReview') modeDisplayName.value = 'é”™é¢˜å›é¡¾';
                    
                     if (mode === 'incorrectReview') { 
                        startIncorrectReview(); 
                    } else {
                        navigateTo('chapterOrderSelection');
                    }
                };

                const toggleChapterSelection = (chapterValue) => {
                    if (chapterValue === 'all') {
                        if (selectedChapters.value.includes('all')) { 
                            selectedChapters.value = [];
                        } else { 
                            selectedChapters.value = availableChapters.value.map(c => c.value);
                        }
                    } else {
                        const index = selectedChapters.value.indexOf(chapterValue);
                        if (index > -1) {
                            selectedChapters.value.splice(index, 1);
                        } else {
                            selectedChapters.value.push(chapterValue);
                        }
                        const allIndividualChapters = availableChapters.value.filter(c => c.value !== 'all');
                        const allIndividualSelected = allIndividualChapters.every(c => selectedChapters.value.includes(c.value));
                        
                        const allIndex = selectedChapters.value.indexOf('all');
                        if (allIndividualSelected && allIndex === -1) {
                            selectedChapters.value.push('all');
                        } else if (!allIndividualSelected && allIndex > -1) {
                            selectedChapters.value.splice(allIndex, 1);
                        }
                    }
                };
                
                const startSelectedMode = async () => { 
                    if (!userId.value) {
                        errorMessage.value = "ç”¨æˆ·æœªåˆå§‹åŒ–ï¼Œè¯·è¿”å›å¹¶è¾“å…¥ç”¨æˆ·IDã€‚";
                        return; 
                    }
                    if (activeMode.value !== 'incorrectReview' && selectedChapters.value.length === 0) {
                        errorMessage.value = "è¯·è‡³å°‘é€‰æ‹©ä¸€ä¸ªç« èŠ‚ã€‚";
                        return;
                    }
                    isLoading.value = true;
                    errorMessage.value = ''; 
                    resetModeState(); 

                    let url = '';
                    let requestBody = { user_id: userId.value };

                    if (activeMode.value === 'quickReview' || activeMode.value === 'quizMode') {
                        url = activeMode.value === 'quickReview' ? `${API_BASE_URL}/api/review/start` : `${API_BASE_URL}/api/quiz/start`;
                        requestBody.chapter_choice = selectedChapters.value.includes('all') ? ['all'] : selectedChapters.value.filter(c => c !== 'all' && c !== undefined && c !== null);
                        requestBody.order_choice = selectedOrder.value;
                    } else {
                        errorMessage.value = "æœªçŸ¥çš„æ¨¡å¼: " + activeMode.value;
                        isLoading.value = false;
                        return;
                    }
                    
                    try {
                        const response = await fetch(url, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(requestBody)
                        });
                        if (!response.ok) {
                            const errBody = await response.text();
                            throw new Error(`å¼€å§‹${modeDisplayName.value}å¤±è´¥: ${response.statusText} (${response.status}) - ${errBody || '(æ— å“åº”ä½“)'}`);
                        }
                        const data = await response.json();
                        if (data && data.questions && Array.isArray(data.questions)) { 
                            allModeQuestions.value = data.questions; 
                            totalQuestions.value = data.questions.length;
                            originalTotalQuestions.value = data.questions.length;
                            if (totalQuestions.value > 0) {
                                currentQuestionIndex.value = 0;
                                setCurrentQuestionFromIndex(); 
                                isQuizCompleted.value = false; 
                                navigateTo(activeMode.value); 
                            } else {
                                errorMessage.value = data.message || "æ‰€é€‰èŒƒå›´æ²¡æœ‰é¢˜ç›®ã€‚";
                                navigateTo('chapterOrderSelection'); 
                            }
                        } else {
                             errorMessage.value = data.message || "æ²¡æœ‰è·å–åˆ°é¢˜ç›®æˆ–å“åº”æ ¼å¼ä¸æ­£ç¡® (æœŸæœ› 'questions' æ•°ç»„)ã€‚";
                             navigateTo('chapterOrderSelection');
                        }
                    } catch (err) {
                        errorMessage.value = err.message;
                    } finally {
                        isLoading.value = false;
                    }
                };

                const setCurrentQuestionFromIndex = () => {
                    if (currentQuestionIndex.value >= 0 && currentQuestionIndex.value < allModeQuestions.value.length) {
                        currentQuestion.value = allModeQuestions.value[currentQuestionIndex.value];
                        // FIXED: Removed the incorrect display_number assignment. Display is now handled by the template.
                        
                        resetQuizStateForNewQuestion(); 
                        quizModeState.value = 'inProgress'; 
                        isQuizCompleted.value = false;
                    } else if (currentQuestionIndex.value >= allModeQuestions.value.length && allModeQuestions.value.length > 0) {
                        isQuizCompleted.value = true;
                        currentQuestion.value = null; 
                    } else { 
                        isQuizCompleted.value = true;
                        currentQuestion.value = null;
                        navigateTo('resultsView');
                    }
                };

                const previousQuestion = () => {
                    if (currentQuestionIndex.value > 0) {
                        quizModeState.value = 'inProgress'; 
                        currentQuestionIndex.value--;
                        setCurrentQuestionFromIndex();
                        // Adjust quiz results if going back
                        if (activeMode.value === 'quizMode' || activeMode.value === 'incorrectReview') {
                           // This logic could be complex, for now we will not decrement total_answered to keep it simple.
                           // User can re-answer but it will not affect the stats for previous questions.
                        }
                    }
                };

                const toggleJumpInput = () => {
                    showJumpInput.value = !showJumpInput.value;
                    if (!showJumpInput.value) jumpToQuestionNumberInput.value = null;
                };

                const jumpToQuestion = () => {
                    const targetNum = parseInt(jumpToQuestionNumberInput.value, 10);
                    if (targetNum && targetNum >= 1 && targetNum <= totalQuestions.value) { 
                        quizModeState.value = 'inProgress'; 
                        currentQuestionIndex.value = targetNum - 1; 
                        setCurrentQuestionFromIndex();
                        showJumpInput.value = false; 
                        jumpToQuestionNumberInput.value = null;
                    } else {
                        alert(`è¯·è¾“å…¥æœ‰æ•ˆçš„é¢˜å· (1-${totalQuestions.value})`);
                    }
                };
                
                const fetchNextQuestion = async () => { 
                    if (isQuizCompleted.value || currentQuestionIndex.value >= totalQuestions.value -1) {
                        isQuizCompleted.value = true;
                        navigateTo('resultsView');
                        return;
                    }
                    if (currentQuestionIndex.value < totalQuestions.value - 1) {
                        currentQuestionIndex.value++;
                        setCurrentQuestionFromIndex();
                    }
                };

                const submitAnswerForMode = async () => {
                    let userAnswerString = '';
                    if (currentQuestion.value?.question_type === 'å¤šé€‰é¢˜') {
                        userAnswerString = Array.isArray(selectedAnswers.value) ? [...selectedAnswers.value].sort().join('') : '';
                    } else { userAnswerString = selectedAnswers.value || ''; }

                    if ((currentQuestion.value?.question_type === 'å•é€‰é¢˜' && !userAnswerString) ||
                        (currentQuestion.value?.question_type === 'å¤šé€‰é¢˜' && userAnswerString.length === 0)) {
                        errorMessage.value = 'è¯·é€‰æ‹©ç­”æ¡ˆåå†æäº¤ï¼'; return;
                    }
                    errorMessage.value = ''; 

                    // --- Instant Feedback Logic ---
                    const correctAnswerProcessed = (currentQuestion.value && typeof currentQuestion.value.correct_answer === 'string') 
                                                ? currentQuestion.value.correct_answer.split('').sort().join('') : '';
                    isCurrentAnswerCorrect.value = userAnswerString === correctAnswerProcessed;
                    feedbackMessage.value = isCurrentAnswerCorrect.value ? 'å›ç­”æ­£ç¡®ï¼ğŸ‘' : `å›ç­”é”™è¯¯ï¼æ­£ç¡®ç­”æ¡ˆæ˜¯ï¼š<strong>${currentQuestion.value.correct_answer}</strong>`;
                    quizModeState.value = 'showAnswer'; 

                    if (activeMode.value === 'quizMode' || activeMode.value === 'incorrectReview') {
                        quizResults.value.total_answered++;
                        if(isCurrentAnswerCorrect.value) quizResults.value.total_correct++;
                    }

                    if (currentQuestionIndex.value >= totalQuestions.value - 1) {
                        isQuizCompleted.value = true;
                    } else {
                        isQuizCompleted.value = false; 
                    }
                    // --- End of Instant Feedback Logic ---
                    
                    let url = '';
                    if (activeMode.value === 'quizMode') url = `${API_BASE_URL}/api/quiz/submit_answer`;
                    else if (activeMode.value === 'incorrectReview') url = `${API_BASE_URL}/api/incorrect_questions/review/submit_answer`;
                    else { 
                        return; 
                    }

                    // Send to server in the background (fire-and-forget)
                    try {
                        const requestBody = {
                            user_id: userId.value,
                            quiz_question_id: currentQuestion.value.quiz_question_id,
                            user_answer: userAnswerString,
                            was_correct: isCurrentAnswerCorrect.value 
                        };
                        fetch(url, { 
                            method: 'POST', 
                            headers: { 'Content-Type': 'application/json' }, 
                            body: JSON.stringify(requestBody) 
                        })
                        .then(response => { 
                            if (!response.ok) { 
                                console.error(`æœåŠ¡å™¨è®°å½•ç­”æ¡ˆå¤±è´¥ (åå°)`);
                            } else {
                                console.log("ç­”æ¡ˆå·²æˆåŠŸåŒæ­¥åˆ°æœåŠ¡å™¨ (åå°)ã€‚");
                            }
                        })
                        .catch(err => {
                            console.error(`æäº¤ç­”æ¡ˆåˆ°æœåŠ¡å™¨æ—¶å‘ç”Ÿç½‘ç»œé”™è¯¯ (åå°): ${err.message}`);
                        });
                        
                    } catch (err) { 
                        console.error(`å‡†å¤‡æäº¤ç­”æ¡ˆåˆ°æœåŠ¡å™¨æ—¶å‡ºé”™ (åå°): ${err.message}`);
                    } 
                };
                                
                const startIncorrectReview = async () => { 
                    if (!userId.value) { errorMessage.value = "ç”¨æˆ·æœªåˆå§‹åŒ–ï¼Œè¯·è¿”å›å¹¶è¾“å…¥ç”¨æˆ·IDã€‚"; return; }
                    isLoading.value = true;
                    errorMessage.value = '';
                    resetModeState(); 
                    activeMode.value = 'incorrectReview'; 
                    modeDisplayName.value = 'é”™é¢˜å›é¡¾';

                    try {
                        const response = await fetch(`${API_BASE_URL}/api/incorrect_questions/review/start`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ user_id: userId.value })
                        });
                        if (!response.ok) { 
                            const errBody = await response.text();
                            throw new Error(`å¼€å§‹é”™é¢˜å›é¡¾å¤±è´¥: ${response.statusText} (${response.status}) - ${errBody || '(æ— å“åº”ä½“)'}`);
                         }
                        const data = await response.json();
                        if (data && data.questions && Array.isArray(data.questions)) { 
                            allModeQuestions.value = data.questions; 
                            totalQuestions.value = data.questions.length;
                            originalTotalQuestions.value = data.questions.length;
                            if (totalQuestions.value > 0) {
                                currentQuestionIndex.value = 0;
                                setCurrentQuestionFromIndex();
                                isQuizCompleted.value = false;
                                navigateTo('incorrectReview'); 
                            } else {
                                errorMessage.value = data.message || "é”™é¢˜ç°¿æ˜¯ç©ºçš„ï¼å¤ªæ£’äº†ï¼";
                                navigateTo('mainMenu');
                            }
                        } else { 
                            errorMessage.value = data.message || "é”™é¢˜ç°¿æ˜¯ç©ºçš„æˆ–æ— æ³•åŠ è½½ã€‚";
                            navigateTo('mainMenu');
                        }
                    } catch (err) { 
                        errorMessage.value = err.message;
                    } 
                    finally { isLoading.value = false; }
                };

                const deleteCurrentIncorrectQuestion = async () => {
                    if (!currentQuestion.value || !userId.value) {
                        errorMessage.value = "æ— æ³•åˆ é™¤ï¼šå½“å‰é—®é¢˜æˆ–ç”¨æˆ·IDæ— æ•ˆã€‚";
                        return;
                    }

                    const questionToDelete = currentQuestion.value;
                    const indexToDelete = currentQuestionIndex.value;

                    // Optimistically update UI
                    allModeQuestions.value.splice(indexToDelete, 1);
                    totalQuestions.value = allModeQuestions.value.length;
                    
                    // Move to the next question or end the quiz.
                    // The index does not need to be incremented because the array has shifted.
                    setCurrentQuestionFromIndex();

                    // Fire-and-forget request to the backend
                    try {
                        const requestBody = {
                            user_id: userId.value,
                            original_chapter: questionToDelete.original_chapter,
                            original_question_number: questionToDelete.original_question_number
                        };
                        
                        fetch(`${API_BASE_URL}/api/incorrect_questions/delete`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(requestBody)
                        }).then(response => {
                            if (!response.ok) {
                                console.error(`åå°åˆ é™¤é”™é¢˜å¤±è´¥ (ç”¨æˆ·: ${userId.value}, é¢˜å·: ${questionToDelete.original_question_number})`);
                            } else {
                                console.log(`é”™é¢˜ (ç”¨æˆ·: ${userId.value}, é¢˜å·: ${questionToDelete.original_question_number}) å·²åœ¨åå°è¯·æ±‚åˆ é™¤ã€‚`);
                            }
                        }).catch(err => {
                            console.error(`å‘é€åˆ é™¤é”™é¢˜è¯·æ±‚æ—¶å‘ç”Ÿç½‘ç»œé”™è¯¯: ${err.message}`);
                        });
                    } catch (err) {
                        console.error(`å‡†å¤‡åˆ é™¤é”™é¢˜è¯·æ±‚æ—¶å‡ºé”™: ${err.message}`);
                    }
                };

                const confirmClearUserData = () => {
                    if (confirm(`å–µå‘œï¼è­¦å‘Šï¼šæ­¤æ“ä½œå°†é‡ç½®ç”¨æˆ· '${userId.value}' çš„æ‰€æœ‰å¯¹é”™ç»Ÿè®¡å¹¶åˆ é™¤é”™é¢˜ç°¿ï¼Œæ•°æ®æ— æ³•æ¢å¤ï¼\nç¡®å®šè¦æ¸…ç†å—ï¼Ÿ`)) {
                        clearUserData();
                    }
                };

                const clearUserData = async () => { 
                    if (!userId.value) { errorMessage.value = "ç”¨æˆ·æœªåˆå§‹åŒ–ï¼Œæ— æ³•æ¸…ç†æ•°æ®ã€‚"; return; }
                    isLoading.value = true;
                    errorMessage.value = '';
                    try {
                        const response = await fetch(`${API_BASE_URL}/api/user/data/clear`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ user_id: userId.value })
                        });
                        if (!response.ok) {
                             const errBody = await response.text();
                             throw new Error(`æ¸…ç†ç”¨æˆ·æ•°æ®å¤±è´¥: ${response.statusText} (${response.status}) - ${errBody || '(æ— å“åº”ä½“)'}`);
                        }
                        const data = await response.json();
                        alert(data.message || "ç”¨æˆ·æ•°æ®å·²æ¸…ç†ã€‚");
                        logoutCurrentUser(false); 
                    } catch (err) { 
                        errorMessage.value = err.message;
                    } 
                    finally { isLoading.value = false; }
                };

                const logoutCurrentUser = (confirmLogout = true) => {
                    if (confirmLogout && !confirm("ç¡®å®šè¦é€€å‡ºå½“å‰ç”¨æˆ·å¹¶è¿”å›ç™»å½•ç•Œé¢å—ï¼Ÿ")) {
                        return;
                    }
                    localStorage.removeItem('quizAppUserId');
                    userId.value = '';
                    inputUserId.value = '';
                    userIdError.value = '';
                    errorMessage.value = ''; 
                    resetModeState(); 
                    currentView.value = 'mainMenu'; 
                };


                const sortedOptions = computed(() => {
                    if (currentQuestion.value && typeof currentQuestion.value.options === 'object' && currentQuestion.value.options !== null) {
                        try {
                            return Object.entries(currentQuestion.value.options)
                                .sort(([keyA], [keyB]) => keyA.localeCompare(keyB))
                                .reduce((obj, [key, value]) => { obj[key] = value; return obj; }, {});
                        } catch (e) { console.error("Error sorting options:", e); return {}; }
                    }
                    return {};
                });

                const formatQuestionText = (text) => text ? text.replace(/\n/g, '<br>') : '';

                const getOptionLabelClass = (optionKey) => {
                    const classes = [];
                    const userAnswersArray = Array.isArray(selectedAnswers.value) 
                                            ? selectedAnswers.value 
                                            : (selectedAnswers.value !== null && selectedAnswers.value !== undefined ? [String(selectedAnswers.value)] : []);
                                            
                    const correctAnswerString = (currentQuestion.value && typeof currentQuestion.value.correct_answer === 'string') 
                                            ? currentQuestion.value.correct_answer
                                            : '';
                    const correctAnswerKeys = correctAnswerString.split('');

                    if ((activeMode.value === 'quizMode' || activeMode.value === 'incorrectReview') && quizModeState.value === 'showAnswer') {
                        const isThisOptionActuallyCorrect = correctAnswerKeys.includes(optionKey);
                        const wasThisOptionSelectedByUser = userAnswersArray.includes(optionKey);

                        if (isThisOptionActuallyCorrect) { 
                            classes.push('correct'); 
                        } else if (wasThisOptionSelectedByUser) { 
                           classes.push('incorrect');
                        }
                    } else if ((activeMode.value === 'quizMode' || activeMode.value === 'incorrectReview') && quizModeState.value === 'inProgress') { 
                         if (userAnswersArray.includes(optionKey)) {
                            classes.push('selected');
                        }
                    }
                    return classes.join(' ');
                };

                const resetQuizStateForNewQuestion = () => {
                    if (currentQuestion.value) { 
                        selectedAnswers.value = currentQuestion.value.question_type === 'å•é€‰é¢˜' ? null : [];
                    } else {
                        selectedAnswers.value = null; 
                    }
                    feedbackMessage.value = '';
                    isCurrentAnswerCorrect.value = false; 
                };

                return {
                    isLoading, errorMessage, userIdError, currentView, viewTitle, userId, inputUserId,
                    availableChapters, selectedChapters, selectedOrder,
                    activeMode, modeDisplayName,
                    allModeQuestions, currentQuestion, totalQuestions, originalTotalQuestions, isQuizCompleted, currentQuestionIndex,
                    selectedAnswers, quizModeState, feedbackMessage, isCurrentAnswerCorrect, quizResults,
                    isInQuestionView, showNextButton,
                    showJumpInput, jumpToQuestionNumberInput,
                    navigateTo, goBackToMenu, selectMode, toggleChapterSelection, startSelectedMode,
                    fetchNextQuestion, submitAnswerForMode, 
                    startIncorrectReview,
                    deleteCurrentIncorrectQuestion,
                    confirmClearUserData, clearUserData, logoutCurrentUser, 
                    sortedOptions, formatQuestionText, getOptionLabelClass,
                    previousQuestion, toggleJumpInput, jumpToQuestion,
                    submitUserId 
                };
            }
        }).mount('#app');
    </script>
</body>
</html>

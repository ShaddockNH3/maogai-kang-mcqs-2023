<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>喵喵学习小助手</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <style>
        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, 'Noto Sans', sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol', 'Noto Color Emoji';
            background-color: #f0f2f5;
            margin: 0; 
            padding: 0; 
        }
        .app-container {
            max-width: 700px; 
            width: 100%; 
            margin: 0 auto; 
            padding: 10px; 
            background-color: white;
            min-height: 100vh; 
            box-sizing: border-box;
        }
        .btn {
            display: inline-block; /* Allow buttons to be side-by-side */
            padding: 8px 12px; /* Adjusted padding for smaller buttons */
            margin-left: 8px; /* Spacing between inline buttons */
            border-radius: 6px; /* Consistent rounding */
            font-weight: 500; /* Adjusted font-weight */
            transition: background-color 0.2s;
            cursor: pointer;
            text-align: center;
            border: 1px solid transparent;
            font-size: 0.875rem; /* text-sm */
            line-height: 1.25rem;
        }
        .btn-full-width { /* Class for buttons that should span full width */
            display: block;
            width: 100%;
            margin-left: 0; /* Reset margin for full-width */
            margin-bottom: 10px;
             padding: 10px 15px; /* Restore padding for full-width buttons */
        }
        .btn-primary { background-color: #4299e1; color: white; }
        .btn-primary:hover { background-color: #2b6cb0; }
        .btn-secondary { background-color: #48bb78; color: white; }
        .btn-secondary:hover { background-color: #38a169; }
        .btn-warning { background-color: #f6ad55; color: white; }
        .btn-warning:hover { background-color: #dd6b20; }
        .btn-danger { background-color: #e53e3e; color: white; }
        .btn-danger:hover { background-color: #c53030; }
        .btn-outline { background-color: white; color: #4a5568; border-color: #cbd5e1; }
        .btn-outline:hover { background-color: #f7fafc; }
        .btn:disabled {
            background-color: #d1d5db; /* gray-300 */
            color: #6b7280; /* gray-500 */
            cursor: not-allowed;
            border-color: #d1d5db;
        }

        .question-card { 
            border: 1px solid #e2e8f0; 
            border-radius: 8px; 
            padding: 12px; 
            margin-bottom: 15px; 
            background-color: #ffffff;
        }
        .option-label { 
            display: block; 
            padding: 10px 12px; 
            margin-bottom: 8px; 
            border: 1px solid #cbd5e1; 
            border-radius: 8px; 
            cursor: pointer; 
            transition: background-color 0.2s, border-color 0.2s; 
        }
        .option-label:hover { background-color: #f7fafc; }
        .option-label.selected { background-color: #ebf8ff; border-color: #4299e1; }
        .option-label.correct { background-color: #c6f6d5; border-color: #38a169; }
        .option-label.incorrect { background-color: #fed7d7; border-color: #e53e3e; }
        
        .feedback-message { 
            padding: 10px; 
            border-radius: 8px; 
            margin-top: 10px; 
            font-weight: 500; 
            min-height: 40px; 
        }
        .feedback-correct { background-color: #c6f6d5; color: #2f855a; }
        .feedback-incorrect { background-color: #fed7d7; color: #c53030; }

        .loading-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(255, 255, 255, 0.8); display: flex; justify-content: center; align-items: center; z-index: 9999; }
        .spinner { border: 4px solid rgba(0, 0, 0, 0.1); width: 36px; height: 36px; border-radius: 50%; border-left-color: #4299e1; animation: spin 1s ease infinite; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        select, input[type="text"], input[type="number"] {
            padding: 8px;
            margin-bottom: 10px;
            border: 1px solid #cbd5e1;
            border-radius: 6px;
            box-sizing: border-box;
        }
        input.jump-input { 
            width: 70px; 
            margin-left: 8px;
            margin-right: 4px; /* Reduced margin to bring Go button closer */
            text-align: center;
        }
        .chapter-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(100px, 1fr)); gap: 8px; margin-bottom: 15px;}
        .chapter-btn { padding: 8px; border: 1px solid #cbd5e1; border-radius: 6px; text-align: center; cursor: pointer; font-size: 0.875rem; }
        .chapter-btn.active { background-color: #4299e1; color: white; border-color: #4299e1;}

        .nav-bar { 
            display: flex; 
            justify-content: space-between; 
            align-items: center; 
            margin-bottom: 15px; 
            padding-bottom: 8px; 
            border-bottom: 1px solid #e2e8f0;
        }
        .nav-bar .btn-group { 
            display: flex;
            align-items: center;
        }
        .nav-bar .btn-group .btn { /* Ensure buttons in group don't take full width */
            width: auto;
        }
         .nav-bar .btn-group input.jump-input {
            height: 37px; /* Match button height */
        }


        .main-title {
            font-size: 1.875rem; 
            font-weight: bold;
            text-align: center;
            margin-bottom: 1.5rem; 
            color: #4a5568; 
        }
        .question-info-bar { 
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.75rem; 
            font-size: 0.875rem; 
        }
        .question-text-area {
            font-size: 1.125rem; 
            color: #2d3748; 
            margin-bottom: 1rem; 
            line-height: 1.6; 
        }
    </style>
</head>
<body>
    <div id="app" class="app-container">
        <div v-if="isLoading" class="loading-overlay">
            <div class="spinner"></div>
        </div>

        <div v-if="errorMessage" class="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded relative mb-4" role="alert">
            <strong class="font-bold">喵呜！出错了：</strong>
            <span class="block sm:inline">{{ errorMessage }}</span>
            <button @click="errorMessage = ''" class="absolute top-0 bottom-0 right-0 px-4 py-3">
                <svg class="fill-current h-6 w-6 text-red-500" role="button" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><title>关闭</title><path d="M14.348 14.849a1.2 1.2 0 0 1-1.697 0L10 11.819l-2.651 3.029a1.2 1.2 0 1 1-1.697-1.697l2.758-3.15-2.759-3.152a1.2 1.2 0 1 1 1.697-1.697L10 8.183l2.651-3.031a1.2 1.2 0 1 1 1.697 1.697l-2.758 3.152 2.758 3.15a1.2 1.2 0 0 1 0 1.698z"/></svg>
            </button>
        </div>

        <div v-if="currentView !== 'mainMenu'" class="nav-bar">
            <button @click="goBackToMenu" class="btn btn-outline">返回主菜单</button>
            <div class="btn-group" v-if="isInQuestionView && allModeQuestions.length > 0 && quizModeState === 'inProgress'">
                 <button @click="toggleJumpInput" class="btn btn-outline">跳转</button>
                 <input v-if="showJumpInput" type="number" v-model.number="jumpToQuestionNumberInput" 
                       min="1" :max="totalQuestions" class="jump-input" placeholder="题号">
                <button v-if="showJumpInput" @click="jumpToQuestion" class="btn btn-primary">Go</button>
                <button @click="previousQuestion" :disabled="currentQuestionIndex === 0" class="btn btn-outline">上一题</button>
            </div>
        </div>
        
        <h1 v-if="!isInQuestionView" class="main-title">
            {{ currentView === 'mainMenu' ? '喵喵学习小助手' : viewTitle }}
        </h1>

        <div v-if="currentView === 'mainMenu'">
            <p class="text-center text-gray-600 mb-6">主人，今天想做些什么呢？</p>
            <button @click="selectMode('quickReview')" class="btn btn-primary btn-full-width">1. 速刷模式</button>
            <button @click="selectMode('quizMode')" class="btn btn-secondary btn-full-width">2. 答题模式</button>
            <button @click="selectMode('incorrectReview')" class="btn btn-warning btn-full-width">3. 错题回顾</button>
            <button @click="navigateTo('controlMode')" class="btn btn-danger btn-full-width">4. 控制模式</button>
        </div>

        <div v-if="currentView === 'chapterOrderSelection'">
             <h2 class="text-xl font-semibold mb-4 text-gray-700">模式设置：{{ modeDisplayName }}</h2>
            <div class="mb-6">
                <label class="block text-gray-700 text-sm font-bold mb-2">选择章节：</label>
                <div class="chapter-grid">
                    <button v-for="chapter in availableChapters" :key="chapter.value"
                            @click="toggleChapterSelection(chapter.value)"
                            :class="{'active': selectedChapters.includes(chapter.value)}"
                            class="chapter-btn">
                        {{ chapter.text }}
                    </button>
                </div>
                 <p class="text-xs text-gray-500 mt-1">提示：选择“全部章节”会自动选中所有章节。再次点击已选章节可取消。</p>
            </div>
            <div class="mb-6" v-if="activeMode !== 'incorrectReview'">
                <label class="block text-gray-700 text-sm font-bold mb-2">题目顺序：</label>
                <div class="flex">
                    <label class="mr-4 inline-flex items-center">
                        <input type="radio" class="form-radio" v-model="selectedOrder" value="sequential">
                        <span class="ml-2">正序</span>
                    </label>
                    <label class="inline-flex items-center">
                        <input type="radio" class="form-radio" v-model="selectedOrder" value="random">
                        <span class="ml-2">随机</span>
                    </label>
                </div>
            </div>
            <button @click="startSelectedMode" class="btn btn-primary btn-full-width" 
                    :disabled="activeMode !== 'incorrectReview' && selectedChapters.length === 0">
                开始 {{ modeDisplayName }}
            </button>
        </div>

        <div v-if="currentQuestion && isInQuestionView">
            <div class="question-card">
                <div class="question-info-bar">
                    <span class="font-semibold text-blue-600">{{ currentQuestion.question_type }}</span>
                    <span class="text-gray-500">
                        第 {{ currentQuestion.display_number }} / {{ totalQuestions }} 题
                        <span v-if="currentQuestion.original_question_number">
                            (原: {{ currentQuestion.original_question_number }} @ {{ currentQuestion.original_chapter }})
                        </span>
                    </span>
                </div>
                <p class="question-text-area" v-html="formatQuestionText(currentQuestion.question_text)"></p>
                <div v-if="currentQuestion.options" :key="currentQuestion.quiz_question_id + '-' + currentQuestion.question_type">
                    <div v-for="(optionText, optionKey) in sortedOptions" :key="optionKey">
                        <label :class="getOptionLabelClass(optionKey)" class="option-label">
                            <input 
                                :type="currentQuestion.question_type === '单选题' ? 'radio' : 'checkbox'"
                                :name="'question_option_' + currentQuestion.quiz_question_id"
                                :value="optionKey"
                                v-model="selectedAnswers"
                                :disabled="quizModeState === 'showAnswer' || currentView === 'quickReview'"
                                class="mr-3 align-middle"
                            >
                            <span class="align-middle">{{ optionKey }}. {{ optionText }}</span>
                        </label>
                    </div>
                </div>
                <div v-if="currentView === 'quickReview' && currentQuestion.correct_answer" 
                     class="mt-3 p-2 bg-green-50 border border-green-200 rounded text-sm">
                    <p class="font-semibold text-green-700">正确答案： {{ currentQuestion.correct_answer }}</p>
                </div>
            </div>
            <div v-if="(currentView === 'quizMode' || currentView === 'incorrectReview') && feedbackMessage && quizModeState === 'showAnswer'" 
                 :class="isCurrentAnswerCorrect ? 'feedback-correct' : 'feedback-incorrect'"
                 class="feedback-message mb-3"
                 v-html="feedbackMessage">
            </div>
            <div class="mt-3">
                <button v-if="(currentView === 'quizMode' || currentView === 'incorrectReview') && quizModeState === 'inProgress'" 
                        @click="submitAnswerForMode" class="btn btn-primary btn-full-width">
                    提交答案
                </button>
                <button v-if="showNextButton" 
                        @click="fetchNextQuestion" class="btn btn-secondary btn-full-width">
                    下一题
                </button>
                <button v-if="isQuizCompleted && isInQuestionView" 
                        @click="navigateTo('resultsView')" class="btn btn-primary btn-full-width">
                    查看本次总结
                </button>
            </div>
        </div>

        <div v-if="currentView === 'resultsView'">
             <h2 class="text-xl font-semibold text-center text-green-600 mb-4">🎉 本轮{{ modeDisplayName }}完成！ 🎉</h2>
            <p class="text-center text-gray-700 mb-2">总共 {{ totalQuestions }} 道题。</p>
            <div v-if="activeMode === 'quizMode'">
                <p class="text-center text-gray-700 mb-2">回答了 {{ quizResults.total_answered }} 道题。</p>
                <p class="text-center text-gray-700 mb-2">答对了 {{ quizResults.total_correct }} 道题。</p>
                <p class="text-center text-gray-700 mb-4">答错了 {{ quizResults.total_answered - quizResults.total_correct }} 道题。</p>
            </div>
             <button @click="goBackToMenu" class="btn btn-primary w-full mt-6">返回主菜单</button>
        </div>

        <div v-if="currentView === 'controlMode'">
            <p class="text-gray-700 mb-4">在这里，您可以清除您在本设备上的所有答题记录（包括错题和统计数据）。此操作不可恢复！</p>
            <button @click="confirmClearUserData" class="btn btn-danger btn-full-width">清理我的数据</button>
        </div>
    </div>

    <script>
        const { createApp, ref, computed, onMounted, watch } = Vue;

        createApp({
            setup() {
                const isLoading = ref(false);
                const errorMessage = ref('');
                const currentView = ref('mainMenu'); 
                const viewTitle = ref('喵喵学习小助手');
                const userId = ref(localStorage.getItem('quizAppUserId') || null);
                const API_BASE_URL = ''; 
                const availableChapters = ref([...Array.from({ length: 9 }, (_, i) => ({ value: i.toString(), text: `章节 ${i}` })), { value: 'all', text: '全部章节' }]);
                const selectedChapters = ref([]); 
                const selectedOrder = ref('sequential'); 
                const activeMode = ref(''); 
                const modeDisplayName = ref('');
                
                const allModeQuestions = ref([]); 
                const currentQuestion = ref(null); 
                const currentQuestionIndex = ref(-1); 
                const totalQuestions = ref(0);
                const isQuizCompleted = ref(false);

                const selectedAnswers = ref([]); 
                const quizModeState = ref('inProgress'); 
                const feedbackMessage = ref('');
                const isCurrentAnswerCorrect = ref(false);
                const quizResults = ref({ total_answered: 0, total_correct: 0 });
                
                const showJumpInput = ref(false);
                const jumpToQuestionNumberInput = ref(null);

                const isInQuestionView = computed(() => {
                    return ['quickReview', 'quizMode', 'incorrectReview'].includes(currentView.value);
                });

                const showNextButton = computed(() => {
                    if (!isInQuestionView.value || isQuizCompleted.value) return false;
                    if (currentView.value === 'quickReview' && currentQuestionIndex.value < totalQuestions.value -1 ) return true;
                    if ((currentView.value === 'quizMode' || currentView.value === 'incorrectReview') && quizModeState.value === 'showAnswer') return true;
                    return false;
                });

                const initializeUser = async () => {
                    if (userId.value) { return; }
                    isLoading.value = true;
                    errorMessage.value = ''; 
                    try {
                        const response = await fetch(`${API_BASE_URL}/api/session/init`, { method: 'POST' });
                        if (!response.ok) {
                            let errorDetailMessage = `HTTP 错误状态: ${response.status} ${response.statusText}. `;
                            try { const errorBodyText = await response.text(); errorDetailMessage += `服务器响应: "${errorBodyText || '(无响应体)'}"`; } catch (e) { errorDetailMessage += "无法读取服务器错误响应体。"; }
                            throw new Error(`无法初始化用户会话。${errorDetailMessage}`);
                        }
                        const data = await response.json();
                        if (data.user_id) {
                            userId.value = data.user_id;
                            localStorage.setItem('quizAppUserId', userId.value);
                        } else {
                            throw new Error("服务器响应中未找到 user_id。");
                        }
                    } catch (err) {
                        errorMessage.value = err.message || "初始化用户会话时发生未知网络错误。";
                    } finally {
                        isLoading.value = false;
                    }
                };

                onMounted(initializeUser);

                watch(currentView, (newView, oldView) => { 
                    switch(newView) {
                        case 'mainMenu': viewTitle.value = '喵喵学习小助手'; break;
                        case 'chapterOrderSelection': viewTitle.value = `模式设置 - ${modeDisplayName.value}`; break;
                        case 'quickReview': viewTitle.value = '速刷模式'; break;
                        case 'quizMode': viewTitle.value = '答题模式'; break;
                        case 'incorrectReview': viewTitle.value = '错题回顾'; break;
                        case 'resultsView': viewTitle.value = '本轮总结'; break;
                        case 'controlMode': viewTitle.value = '控制模式'; break;
                        default: viewTitle.value = '喵喵学习小助手';
                    }
                    if (newView !== 'mainMenu' && !userId.value) { 
                        initializeUser();
                    }
                    errorMessage.value = ''; 
                    if (!isInQuestionView.value) { 
                        showJumpInput.value = false;
                    }
                });
                
                const navigateTo = (view) => {
                    currentView.value = view;
                };

                const goBackToMenu = () => {
                    resetModeState();
                    navigateTo('mainMenu');
                };

                const resetModeState = () => {
                    allModeQuestions.value = [];
                    currentQuestion.value = null;
                    currentQuestionIndex.value = -1;
                    totalQuestions.value = 0;
                    isQuizCompleted.value = false;
                    selectedAnswers.value = [];
                    feedbackMessage.value = '';
                    quizModeState.value = 'inProgress';
                    quizResults.value = { total_answered: 0, total_correct: 0 };
                    showJumpInput.value = false;
                    jumpToQuestionNumberInput.value = null;
                };
                
                const selectMode = (mode) => { 
                    if (!userId.value) {
                        errorMessage.value = "用户ID尚未初始化，请稍后或刷新页面重试。";
                        initializeUser(); 
                        return;
                    }
                    activeMode.value = mode; 
                    selectedChapters.value = []; 
                    selectedOrder.value = 'sequential'; 
                    
                    if (mode === 'quickReview') modeDisplayName.value = '速刷模式';
                    else if (mode === 'quizMode') modeDisplayName.value = '答题模式';
                    else if (mode === 'incorrectReview') modeDisplayName.value = '错题回顾';
                    
                    // For incorrectReview, we now also go to startSelectedMode,
                    // as it will call startIncorrectReview internally.
                    // navigateTo('chapterOrderSelection'); // Incorrect review does not use chapter selection
                     if (mode === 'incorrectReview') { 
                        startIncorrectReview(); 
                    } else {
                        navigateTo('chapterOrderSelection');
                    }
                };

                const toggleChapterSelection = (chapterValue) => {
                    if (chapterValue === 'all') {
                        if (selectedChapters.value.includes('all')) { 
                            selectedChapters.value = [];
                        } else { 
                            selectedChapters.value = availableChapters.value.map(c => c.value);
                        }
                    } else {
                        const index = selectedChapters.value.indexOf(chapterValue);
                        if (index > -1) {
                            selectedChapters.value.splice(index, 1);
                        } else {
                            selectedChapters.value.push(chapterValue);
                        }
                        const allIndividualChapters = availableChapters.value.filter(c => c.value !== 'all');
                        const allIndividualSelected = allIndividualChapters.every(c => selectedChapters.value.includes(c.value));
                        if (allIndividualSelected && !selectedChapters.value.includes('all')) {
                            selectedChapters.value.push('all');
                        } else if (!allIndividualSelected && selectedChapters.value.includes('all')) {
                            const allIndex = selectedChapters.value.indexOf('all');
                            if (allIndex > -1) selectedChapters.value.splice(allIndex, 1);
                        }
                    }
                };
                
                const startSelectedMode = async () => { 
                    if (!userId.value) {
                        errorMessage.value = "用户未初始化，请刷新页面或检查网络连接。";
                        await initializeUser(); 
                        if (!userId.value) return; 
                    }
                     // For incorrectReview, chapter selection is not applicable.
                    if (activeMode.value !== 'incorrectReview' && selectedChapters.value.length === 0) {
                        errorMessage.value = "请至少选择一个章节。";
                        return;
                    }
                    isLoading.value = true;
                    resetModeState(); // Reset before starting a new mode

                    let url = '';
                    let requestBody = { user_id: userId.value };

                    if (activeMode.value === 'quickReview') {
                        url = `${API_BASE_URL}/api/review/start`;
                        requestBody.chapter_choice = selectedChapters.value.includes('all') ? ['all'] : selectedChapters.value.filter(c => c !== 'all');
                        requestBody.order_choice = selectedOrder.value;
                    } else if (activeMode.value === 'quizMode') {
                        url = `${API_BASE_URL}/api/quiz/start`;
                        requestBody.chapter_choice = selectedChapters.value.includes('all') ? ['all'] : selectedChapters.value.filter(c => c !== 'all');
                        requestBody.order_choice = selectedOrder.value;
                    } 
                    // incorrectReview is handled by its own start function
                     else {
                        errorMessage.value = "未知的模式: " + activeMode.value;
                        isLoading.value = false;
                        return;
                    }
                    
                    try {
                        const response = await fetch(url, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(requestBody)
                        });
                        if (!response.ok) {
                            const errBody = await response.text();
                            throw new Error(`开始${modeDisplayName.value}失败: ${response.statusText} (${response.status}) - ${errBody || '(无响应体)'}`);
                        }
                        const data = await response.json();
                        // EXPECTING 'questions' ARRAY FROM BACKEND NOW
                        if (data && data.questions && Array.isArray(data.questions)) { 
                            allModeQuestions.value = data.questions; 
                            totalQuestions.value = data.questions.length;
                            if (totalQuestions.value > 0) {
                                currentQuestionIndex.value = 0;
                                setCurrentQuestionFromIndex(); // This will set currentQuestion and reset states
                                isQuizCompleted.value = false; // Quiz starts, not completed
                                navigateTo(activeMode.value); 
                            } else {
                                errorMessage.value = data.message || "所选范围没有题目。";
                                navigateTo('chapterOrderSelection'); 
                            }
                        } else {
                             errorMessage.value = data.message || "没有获取到题目或响应格式不正确 (期望 'questions' 数组)。";
                             navigateTo('chapterOrderSelection');
                        }
                    } catch (err) {
                        errorMessage.value = err.message;
                    } finally {
                        isLoading.value = false;
                    }
                };

                const setCurrentQuestionFromIndex = () => {
                    if (currentQuestionIndex.value >= 0 && currentQuestionIndex.value < allModeQuestions.value.length) {
                        currentQuestion.value = allModeQuestions.value[currentQuestionIndex.value];
                        // Update display number based on the new index
                        if(currentQuestion.value) currentQuestion.value.display_number = currentQuestionIndex.value + 1;
                        
                        resetQuizStateForNewQuestion(); 
                        quizModeState.value = 'inProgress'; 
                        isQuizCompleted.value = false;
                    } else if (currentQuestionIndex.value >= allModeQuestions.value.length && allModeQuestions.value.length > 0) {
                        isQuizCompleted.value = true;
                        currentQuestion.value = null; 
                    } else {
                        isQuizCompleted.value = true;
                        currentQuestion.value = null;
                    }
                };

                const previousQuestion = () => {
                    if (currentQuestionIndex.value > 0) {
                        quizModeState.value = 'inProgress'; 
                        currentQuestionIndex.value--;
                        setCurrentQuestionFromIndex();
                    }
                };

                const toggleJumpInput = () => {
                    showJumpInput.value = !showJumpInput.value;
                    if (!showJumpInput.value) jumpToQuestionNumberInput.value = null;
                };

                const jumpToQuestion = () => {
                    const targetNum = parseInt(jumpToQuestionNumberInput.value, 10);
                    if (targetNum && targetNum >= 1 && targetNum <= totalQuestions.value) {
                        quizModeState.value = 'inProgress'; 
                        currentQuestionIndex.value = targetNum - 1; 
                        setCurrentQuestionFromIndex();
                        showJumpInput.value = false; 
                        jumpToQuestionNumberInput.value = null;
                    } else {
                        alert(`请输入有效的题号 (1-${totalQuestions.value})`);
                    }
                };
                
                const fetchNextQuestion = async () => { 
                    if (isQuizCompleted.value) {
                        navigateTo('resultsView');
                        return;
                    }
                    if (currentQuestionIndex.value < totalQuestions.value - 1) {
                        currentQuestionIndex.value++;
                        setCurrentQuestionFromIndex();
                    } else { 
                        isQuizCompleted.value = true;
                        if (quizModeState.value === 'showAnswer' || currentView.value === 'quickReview') { 
                           navigateTo('resultsView');
                        }
                    }
                };

                const submitAnswerForMode = async () => {
                    let userAnswerString = '';
                    if (currentQuestion.value?.question_type === '多选题') {
                        userAnswerString = Array.isArray(selectedAnswers.value) ? [...selectedAnswers.value].sort().join('') : '';
                    } else { userAnswerString = selectedAnswers.value || ''; }

                    if ((currentQuestion.value?.question_type === '单选题' && !userAnswerString) ||
                        (currentQuestion.value?.question_type === '多选题' && userAnswerString.length === 0)) {
                        errorMessage.value = '请选择答案后再提交！'; return;
                    }

                    const correctAnswerProcessed = (currentQuestion.value && typeof currentQuestion.value.correct_answer === 'string') 
                                                ? currentQuestion.value.correct_answer.split('').sort().join('') : '';
                    isCurrentAnswerCorrect.value = userAnswerString === correctAnswerProcessed;
                    feedbackMessage.value = isCurrentAnswerCorrect.value ? '回答正确！👍' : `回答错误！正确答案是：<strong>${currentQuestion.value.correct_answer}</strong>`;
                    quizModeState.value = 'showAnswer'; 
                    
                    isLoading.value = true; errorMessage.value = '';
                    let url = '';
                    if (activeMode.value === 'quizMode') url = `${API_BASE_URL}/api/quiz/submit_answer`;
                    else if (activeMode.value === 'incorrectReview') url = `${API_BASE_URL}/api/incorrect_questions/review/submit_answer`;
                    else { isLoading.value = false; return; }

                    try {
                        const requestBody = {
                            user_id: userId.value,
                            quiz_question_id: currentQuestion.value.quiz_question_id,
                            user_answer: userAnswerString,
                            was_correct: isCurrentAnswerCorrect.value 
                        };
                        const response = await fetch(url, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(requestBody) });
                        if (!response.ok) { 
                            const errBody = await response.text();
                            throw new Error(`提交答案记录失败: ${response.statusText} (${response.status}) - ${errBody || '(无响应体)'}`);
                        }
                        const data = await response.json(); 
                        
                        if (currentQuestionIndex.value >= totalQuestions.value - 1) {
                           isQuizCompleted.value = true;
                        } else {
                           isQuizCompleted.value = false; 
                        }
                        if (data.total_questions_answered && activeMode.value === 'quizMode') {
                             quizResults.value.total_answered = data.total_questions_answered;
                             if (isCurrentAnswerCorrect.value) { 
                                if (quizResults.value.total_correct === undefined) quizResults.value.total_correct = 0;
                                quizResults.value.total_correct++;
                             }
                        }

                    } catch (err) { errorMessage.value = err.message; } 
                    finally { isLoading.value = false; }
                };
                                
                const startIncorrectReview = async () => { 
                    if (!userId.value) { errorMessage.value = "用户未初始化，请刷新页面。"; await initializeUser(); if (!userId.value) return; }
                    isLoading.value = true;
                    resetModeState(); 
                    activeMode.value = 'incorrectReview'; 
                    viewTitle.value = '错题回顾'; 
                    // quizModeState is reset in resetModeState to 'inProgress'

                    try {
                        const response = await fetch(`${API_BASE_URL}/api/incorrect_questions/review/start`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ user_id: userId.value })
                        });
                        if (!response.ok) { 
                            const errBody = await response.text();
                            throw new Error(`开始错题回顾失败: ${response.statusText} (${response.status}) - ${errBody || '(无响应体)'}`);
                         }
                        const data = await response.json();
                        // Backend now sends array of questions in 'questions' field
                        if (data && data.questions && Array.isArray(data.questions)) { 
                            allModeQuestions.value = data.questions; 
                            totalQuestions.value = data.questions.length;
                            if (totalQuestions.value > 0) {
                                currentQuestionIndex.value = 0;
                                setCurrentQuestionFromIndex();
                                isQuizCompleted.value = false;
                                navigateTo('incorrectReview'); 
                            } else {
                                errorMessage.value = data.message || "错题簿是空的！";
                                navigateTo('mainMenu');
                            }
                        } else { 
                            errorMessage.value = data.message || "错题簿是空的或无法加载。";
                            navigateTo('mainMenu');
                        }
                    } catch (err) { 
                        errorMessage.value = err.message;
                    } 
                    finally { isLoading.value = false; }
                };
                const confirmClearUserData = () => {
                    if (confirm("喵呜！警告：此操作将重置您所有的对错统计并删除错题簿，数据无法恢复！\n确定要清理吗？")) {
                        clearUserData();
                    }
                };
                const clearUserData = async () => { 
                    if (!userId.value) { errorMessage.value = "用户未初始化，无法清理数据。"; await initializeUser(); if (!userId.value) return; }
                    isLoading.value = true;
                    try {
                        const response = await fetch(`${API_BASE_URL}/api/user/data/clear`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ user_id: userId.value })
                        });
                        if (!response.ok) {
                             const errBody = await response.text();
                             throw new Error(`清理用户数据失败: ${response.statusText} (${response.status}) - ${errBody || '(无响应体)'}`);
                        }
                        const data = await response.json();
                        alert(data.message || "用户数据已清理。");
                        goBackToMenu(); 
                    } catch (err) { 
                        errorMessage.value = err.message;
                    } 
                    finally { isLoading.value = false; }
                };
                const sortedOptions = computed(() => {
                    if (currentQuestion.value && typeof currentQuestion.value.options === 'object' && currentQuestion.value.options !== null) {
                        try {
                            return Object.entries(currentQuestion.value.options)
                                .sort(([keyA], [keyB]) => keyA.localeCompare(keyB))
                                .reduce((obj, [key, value]) => { obj[key] = value; return obj; }, {});
                        } catch (e) { return {}; }
                    }
                    return {};
                });
                const formatQuestionText = (text) => text ? text.replace(/\n/g, '<br>') : '';
                const getOptionLabelClass = (optionKey) => {
                    const classes = [];
                    const userAnswersArray = Array.isArray(selectedAnswers.value) 
                                            ? selectedAnswers.value 
                                            : (selectedAnswers.value !== null && selectedAnswers.value !== undefined ? [String(selectedAnswers.value)] : []);
                                            
                    const correctAnswerString = (currentQuestion.value && typeof currentQuestion.value.correct_answer === 'string') 
                                            ? currentQuestion.value.correct_answer
                                            : '';
                    const correctAnswerKeys = correctAnswerString.split('');

                    if ((activeMode.value === 'quizMode' || activeMode.value === 'incorrectReview') && quizModeState.value === 'showAnswer') {
                        const isThisOptionActuallyCorrect = correctAnswerKeys.includes(optionKey);
                        const wasThisOptionSelectedByUser = userAnswersArray.includes(optionKey);

                        if (isThisOptionActuallyCorrect) { 
                            classes.push('correct'); 
                        } else if (wasThisOptionSelectedByUser) { 
                           classes.push('incorrect');
                        }
                    } else if ((activeMode.value === 'quizMode' || activeMode.value === 'incorrectReview') && quizModeState.value === 'inProgress') { 
                         if (userAnswersArray.includes(optionKey)) {
                            classes.push('selected');
                        }
                    }
                    return classes.join(' ');
                };
                const resetQuizStateForNewQuestion = () => {
                    if (currentQuestion.value) { 
                        selectedAnswers.value = currentQuestion.value.question_type === '单选题' ? null : [];
                    } else {
                        selectedAnswers.value = null; 
                    }
                    feedbackMessage.value = '';
                    isCurrentAnswerCorrect.value = false; 
                };

                return {
                    isLoading, errorMessage, currentView, viewTitle, userId,
                    availableChapters, selectedChapters, selectedOrder,
                    activeMode, modeDisplayName,
                    allModeQuestions, currentQuestion, totalQuestions, isQuizCompleted, currentQuestionIndex,
                    selectedAnswers, quizModeState, feedbackMessage, isCurrentAnswerCorrect, quizResults,
                    isInQuestionView, showNextButton,
                    showJumpInput, jumpToQuestionNumberInput,
                    navigateTo, goBackToMenu, selectMode, toggleChapterSelection, startSelectedMode,
                    fetchNextQuestion, submitAnswerForMode, 
                    startIncorrectReview,
                    confirmClearUserData, clearUserData,
                    sortedOptions, formatQuestionText, getOptionLabelClass,
                    previousQuestion, toggleJumpInput, jumpToQuestion
                };
            }
        }).mount('#app');
    </script>
</body>
</html>

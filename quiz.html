<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å–µå–µå­¦ä¹ å°åŠ©æ‰‹</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <style>
        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, 'Noto Sans', sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol', 'Noto Color Emoji';
            background-color: #f0f2f5;
            margin: 0; 
            padding: 0; 
        }
        .app-container {
            max-width: 700px; 
            width: 100%; 
            margin: 0 auto; 
            padding: 10px; 
            background-color: white;
            min-height: 100vh; 
            box-sizing: border-box;
        }
        .btn {
            display: inline-block; /* Allow buttons to be side-by-side */
            padding: 8px 12px; /* Adjusted padding for smaller buttons */
            margin-left: 8px; /* Spacing between inline buttons */
            border-radius: 6px; /* Consistent rounding */
            font-weight: 500; /* Adjusted font-weight */
            transition: background-color 0.2s;
            cursor: pointer;
            text-align: center;
            border: 1px solid transparent;
            font-size: 0.875rem; /* text-sm */
            line-height: 1.25rem;
        }
        .btn-full-width { /* Class for buttons that should span full width */
            display: block;
            width: 100%;
            margin-left: 0; /* Reset margin for full-width */
            margin-bottom: 10px;
             padding: 10px 15px; /* Restore padding for full-width buttons */
        }
        .btn-primary { background-color: #4299e1; color: white; }
        .btn-primary:hover { background-color: #2b6cb0; }
        .btn-secondary { background-color: #48bb78; color: white; }
        .btn-secondary:hover { background-color: #38a169; }
        .btn-warning { background-color: #f6ad55; color: white; }
        .btn-warning:hover { background-color: #dd6b20; }
        .btn-danger { background-color: #e53e3e; color: white; }
        .btn-danger:hover { background-color: #c53030; }
        .btn-outline { background-color: white; color: #4a5568; border-color: #cbd5e1; }
        .btn-outline:hover { background-color: #f7fafc; }
        .btn:disabled {
            background-color: #d1d5db; /* gray-300 */
            color: #6b7280; /* gray-500 */
            cursor: not-allowed;
            border-color: #d1d5db;
        }

        .question-card { 
            border: 1px solid #e2e8f0; 
            border-radius: 8px; 
            padding: 12px; 
            margin-bottom: 15px; 
            background-color: #ffffff;
        }
        .option-label { 
            display: block; 
            padding: 10px 12px; 
            margin-bottom: 8px; 
            border: 1px solid #cbd5e1; 
            border-radius: 8px; 
            cursor: pointer; 
            transition: background-color 0.2s, border-color 0.2s; 
        }
        .option-label:hover { background-color: #f7fafc; }
        .option-label.selected { background-color: #ebf8ff; border-color: #4299e1; }
        .option-label.correct { background-color: #c6f6d5; border-color: #38a169; }
        .option-label.incorrect { background-color: #fed7d7; border-color: #e53e3e; }
        
        .feedback-message { 
            padding: 10px; 
            border-radius: 8px; 
            margin-top: 10px; 
            font-weight: 500; 
            min-height: 40px; 
        }
        .feedback-correct { background-color: #c6f6d5; color: #2f855a; }
        .feedback-incorrect { background-color: #fed7d7; color: #c53030; }

        .loading-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(255, 255, 255, 0.8); display: flex; justify-content: center; align-items: center; z-index: 9999; }
        .spinner { border: 4px solid rgba(0, 0, 0, 0.1); width: 36px; height: 36px; border-radius: 50%; border-left-color: #4299e1; animation: spin 1s ease infinite; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        select, input[type="text"], input[type="number"] {
            padding: 8px;
            margin-bottom: 10px;
            border: 1px solid #cbd5e1;
            border-radius: 6px;
            box-sizing: border-box;
        }
        input.jump-input { 
            width: 70px; 
            margin-left: 8px;
            margin-right: 4px; /* Reduced margin to bring Go button closer */
            text-align: center;
        }
        .chapter-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(100px, 1fr)); gap: 8px; margin-bottom: 15px;}
        .chapter-btn { padding: 8px; border: 1px solid #cbd5e1; border-radius: 6px; text-align: center; cursor: pointer; font-size: 0.875rem; }
        .chapter-btn.active { background-color: #4299e1; color: white; border-color: #4299e1;}

        .nav-bar { 
            display: flex; 
            justify-content: space-between; 
            align-items: center; 
            margin-bottom: 15px; 
            padding-bottom: 8px; 
            border-bottom: 1px solid #e2e8f0;
        }
        .nav-bar .btn-group { 
            display: flex;
            align-items: center;
        }
        .nav-bar .btn-group .btn { /* Ensure buttons in group don't take full width */
            width: auto;
        }
         .nav-bar .btn-group input.jump-input {
            height: 37px; /* Match button height */
        }


        .main-title {
            font-size: 1.875rem; 
            font-weight: bold;
            text-align: center;
            margin-bottom: 1.5rem; 
            color: #4a5568; 
        }
        .question-info-bar { 
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.75rem; 
            font-size: 0.875rem; 
        }
        .question-text-area {
            font-size: 1.125rem; 
            color: #2d3748; 
            margin-bottom: 1rem; 
            line-height: 1.6; 
        }
    </style>
</head>
<body>
    <div id="app" class="app-container">
        <div v-if="isLoading" class="loading-overlay">
            <div class="spinner"></div>
        </div>

        <div v-if="errorMessage" class="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded relative mb-4" role="alert">
            <strong class="font-bold">å–µå‘œï¼å‡ºé”™äº†ï¼š</strong>
            <span class="block sm:inline">{{ errorMessage }}</span>
            <button @click="errorMessage = ''" class="absolute top-0 bottom-0 right-0 px-4 py-3">
                <svg class="fill-current h-6 w-6 text-red-500" role="button" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><title>å…³é—­</title><path d="M14.348 14.849a1.2 1.2 0 0 1-1.697 0L10 11.819l-2.651 3.029a1.2 1.2 0 1 1-1.697-1.697l2.758-3.15-2.759-3.152a1.2 1.2 0 1 1 1.697-1.697L10 8.183l2.651-3.031a1.2 1.2 0 1 1 1.697 1.697l-2.758 3.152 2.758 3.15a1.2 1.2 0 0 1 0 1.698z"/></svg>
            </button>
        </div>

        <div v-if="currentView !== 'mainMenu'" class="nav-bar">
            <button @click="goBackToMenu" class="btn btn-outline">è¿”å›ä¸»èœå•</button>
            <div class="btn-group" v-if="isInQuestionView && allModeQuestions.length > 0 && quizModeState === 'inProgress'">
                 <button @click="toggleJumpInput" class="btn btn-outline">è·³è½¬</button>
                 <input v-if="showJumpInput" type="number" v-model.number="jumpToQuestionNumberInput" 
                       min="1" :max="totalQuestions" class="jump-input" placeholder="é¢˜å·">
                <button v-if="showJumpInput" @click="jumpToQuestion" class="btn btn-primary">Go</button>
                <button @click="previousQuestion" :disabled="currentQuestionIndex === 0" class="btn btn-outline">ä¸Šä¸€é¢˜</button>
            </div>
        </div>
        
        <h1 v-if="!isInQuestionView" class="main-title">
            {{ currentView === 'mainMenu' ? 'å–µå–µå­¦ä¹ å°åŠ©æ‰‹' : viewTitle }}
        </h1>

        <div v-if="currentView === 'mainMenu'">
            <p class="text-center text-gray-600 mb-6">ä¸»äººï¼Œä»Šå¤©æƒ³åšäº›ä»€ä¹ˆå‘¢ï¼Ÿ</p>
            <button @click="selectMode('quickReview')" class="btn btn-primary btn-full-width">1. é€Ÿåˆ·æ¨¡å¼</button>
            <button @click="selectMode('quizMode')" class="btn btn-secondary btn-full-width">2. ç­”é¢˜æ¨¡å¼</button>
            <button @click="selectMode('incorrectReview')" class="btn btn-warning btn-full-width">3. é”™é¢˜å›é¡¾</button>
            <button @click="navigateTo('controlMode')" class="btn btn-danger btn-full-width">4. æ§åˆ¶æ¨¡å¼</button>
        </div>

        <div v-if="currentView === 'chapterOrderSelection'">
             <h2 class="text-xl font-semibold mb-4 text-gray-700">æ¨¡å¼è®¾ç½®ï¼š{{ modeDisplayName }}</h2>
            <div class="mb-6">
                <label class="block text-gray-700 text-sm font-bold mb-2">é€‰æ‹©ç« èŠ‚ï¼š</label>
                <div class="chapter-grid">
                    <button v-for="chapter in availableChapters" :key="chapter.value"
                            @click="toggleChapterSelection(chapter.value)"
                            :class="{'active': selectedChapters.includes(chapter.value)}"
                            class="chapter-btn">
                        {{ chapter.text }}
                    </button>
                </div>
                 <p class="text-xs text-gray-500 mt-1">æç¤ºï¼šé€‰æ‹©â€œå…¨éƒ¨ç« èŠ‚â€ä¼šè‡ªåŠ¨é€‰ä¸­æ‰€æœ‰ç« èŠ‚ã€‚å†æ¬¡ç‚¹å‡»å·²é€‰ç« èŠ‚å¯å–æ¶ˆã€‚</p>
            </div>
            <div class="mb-6" v-if="activeMode !== 'incorrectReview'">
                <label class="block text-gray-700 text-sm font-bold mb-2">é¢˜ç›®é¡ºåºï¼š</label>
                <div class="flex">
                    <label class="mr-4 inline-flex items-center">
                        <input type="radio" class="form-radio" v-model="selectedOrder" value="sequential">
                        <span class="ml-2">æ­£åº</span>
                    </label>
                    <label class="inline-flex items-center">
                        <input type="radio" class="form-radio" v-model="selectedOrder" value="random">
                        <span class="ml-2">éšæœº</span>
                    </label>
                </div>
            </div>
            <button @click="startSelectedMode" class="btn btn-primary btn-full-width" 
                    :disabled="activeMode !== 'incorrectReview' && selectedChapters.length === 0">
                å¼€å§‹ {{ modeDisplayName }}
            </button>
        </div>

        <div v-if="currentQuestion && isInQuestionView">
            <div class="question-card">
                <div class="question-info-bar">
                    <span class="font-semibold text-blue-600">{{ currentQuestion.question_type }}</span>
                    <span class="text-gray-500">
                        ç¬¬ {{ currentQuestion.display_number }} / {{ totalQuestions }} é¢˜
                        <span v-if="currentQuestion.original_question_number">
                            (åŸ: {{ currentQuestion.original_question_number }} @ {{ currentQuestion.original_chapter }})
                        </span>
                    </span>
                </div>
                <p class="question-text-area" v-html="formatQuestionText(currentQuestion.question_text)"></p>
                <div v-if="currentQuestion.options" :key="currentQuestion.quiz_question_id + '-' + currentQuestion.question_type">
                    <div v-for="(optionText, optionKey) in sortedOptions" :key="optionKey">
                        <label :class="getOptionLabelClass(optionKey)" class="option-label">
                            <input 
                                :type="currentQuestion.question_type === 'å•é€‰é¢˜' ? 'radio' : 'checkbox'"
                                :name="'question_option_' + currentQuestion.quiz_question_id"
                                :value="optionKey"
                                v-model="selectedAnswers"
                                :disabled="quizModeState === 'showAnswer' || currentView === 'quickReview'"
                                class="mr-3 align-middle"
                            >
                            <span class="align-middle">{{ optionKey }}. {{ optionText }}</span>
                        </label>
                    </div>
                </div>
                <div v-if="currentView === 'quickReview' && currentQuestion.correct_answer" 
                     class="mt-3 p-2 bg-green-50 border border-green-200 rounded text-sm">
                    <p class="font-semibold text-green-700">æ­£ç¡®ç­”æ¡ˆï¼š {{ currentQuestion.correct_answer }}</p>
                </div>
            </div>
            <div v-if="(currentView === 'quizMode' || currentView === 'incorrectReview') && feedbackMessage && quizModeState === 'showAnswer'" 
                 :class="isCurrentAnswerCorrect ? 'feedback-correct' : 'feedback-incorrect'"
                 class="feedback-message mb-3"
                 v-html="feedbackMessage">
            </div>
            <div class="mt-3">
                <button v-if="(currentView === 'quizMode' || currentView === 'incorrectReview') && quizModeState === 'inProgress'" 
                        @click="submitAnswerForMode" class="btn btn-primary btn-full-width">
                    æäº¤ç­”æ¡ˆ
                </button>
                <button v-if="showNextButton" 
                        @click="fetchNextQuestion" class="btn btn-secondary btn-full-width">
                    ä¸‹ä¸€é¢˜
                </button>
                <button v-if="isQuizCompleted && isInQuestionView" 
                        @click="navigateTo('resultsView')" class="btn btn-primary btn-full-width">
                    æŸ¥çœ‹æœ¬æ¬¡æ€»ç»“
                </button>
            </div>
        </div>

        <div v-if="currentView === 'resultsView'">
             <h2 class="text-xl font-semibold text-center text-green-600 mb-4">ğŸ‰ æœ¬è½®{{ modeDisplayName }}å®Œæˆï¼ ğŸ‰</h2>
            <p class="text-center text-gray-700 mb-2">æ€»å…± {{ totalQuestions }} é“é¢˜ã€‚</p>
            <div v-if="activeMode === 'quizMode'">
                <p class="text-center text-gray-700 mb-2">å›ç­”äº† {{ quizResults.total_answered }} é“é¢˜ã€‚</p>
                <p class="text-center text-gray-700 mb-2">ç­”å¯¹äº† {{ quizResults.total_correct }} é“é¢˜ã€‚</p>
                <p class="text-center text-gray-700 mb-4">ç­”é”™äº† {{ quizResults.total_answered - quizResults.total_correct }} é“é¢˜ã€‚</p>
            </div>
             <button @click="goBackToMenu" class="btn btn-primary w-full mt-6">è¿”å›ä¸»èœå•</button>
        </div>

        <div v-if="currentView === 'controlMode'">
            <p class="text-gray-700 mb-4">åœ¨è¿™é‡Œï¼Œæ‚¨å¯ä»¥æ¸…é™¤æ‚¨åœ¨æœ¬è®¾å¤‡ä¸Šçš„æ‰€æœ‰ç­”é¢˜è®°å½•ï¼ˆåŒ…æ‹¬é”™é¢˜å’Œç»Ÿè®¡æ•°æ®ï¼‰ã€‚æ­¤æ“ä½œä¸å¯æ¢å¤ï¼</p>
            <button @click="confirmClearUserData" class="btn btn-danger btn-full-width">æ¸…ç†æˆ‘çš„æ•°æ®</button>
        </div>
    </div>

    <script>
        const { createApp, ref, computed, onMounted, watch } = Vue;

        createApp({
            setup() {
                const isLoading = ref(false);
                const errorMessage = ref('');
                const currentView = ref('mainMenu'); 
                const viewTitle = ref('å–µå–µå­¦ä¹ å°åŠ©æ‰‹');
                const userId = ref(localStorage.getItem('quizAppUserId') || null);
                const API_BASE_URL = ''; 
                const availableChapters = ref([...Array.from({ length: 9 }, (_, i) => ({ value: i.toString(), text: `ç« èŠ‚ ${i}` })), { value: 'all', text: 'å…¨éƒ¨ç« èŠ‚' }]);
                const selectedChapters = ref([]); 
                const selectedOrder = ref('sequential'); 
                const activeMode = ref(''); 
                const modeDisplayName = ref('');
                
                const allModeQuestions = ref([]); 
                const currentQuestion = ref(null); 
                const currentQuestionIndex = ref(-1); 
                const totalQuestions = ref(0);
                const isQuizCompleted = ref(false);

                const selectedAnswers = ref([]); 
                const quizModeState = ref('inProgress'); 
                const feedbackMessage = ref('');
                const isCurrentAnswerCorrect = ref(false);
                const quizResults = ref({ total_answered: 0, total_correct: 0 });
                
                const showJumpInput = ref(false);
                const jumpToQuestionNumberInput = ref(null);

                const isInQuestionView = computed(() => {
                    return ['quickReview', 'quizMode', 'incorrectReview'].includes(currentView.value);
                });

                const showNextButton = computed(() => {
                    if (!isInQuestionView.value || isQuizCompleted.value) return false;
                    if (currentView.value === 'quickReview' && currentQuestionIndex.value < totalQuestions.value -1 ) return true;
                    if ((currentView.value === 'quizMode' || currentView.value === 'incorrectReview') && quizModeState.value === 'showAnswer') return true;
                    return false;
                });

                const initializeUser = async () => {
                    if (userId.value) { return; }
                    isLoading.value = true;
                    errorMessage.value = ''; 
                    try {
                        const response = await fetch(`${API_BASE_URL}/api/session/init`, { method: 'POST' });
                        if (!response.ok) {
                            let errorDetailMessage = `HTTP é”™è¯¯çŠ¶æ€: ${response.status} ${response.statusText}. `;
                            try { const errorBodyText = await response.text(); errorDetailMessage += `æœåŠ¡å™¨å“åº”: "${errorBodyText || '(æ— å“åº”ä½“)'}"`; } catch (e) { errorDetailMessage += "æ— æ³•è¯»å–æœåŠ¡å™¨é”™è¯¯å“åº”ä½“ã€‚"; }
                            throw new Error(`æ— æ³•åˆå§‹åŒ–ç”¨æˆ·ä¼šè¯ã€‚${errorDetailMessage}`);
                        }
                        const data = await response.json();
                        if (data.user_id) {
                            userId.value = data.user_id;
                            localStorage.setItem('quizAppUserId', userId.value);
                        } else {
                            throw new Error("æœåŠ¡å™¨å“åº”ä¸­æœªæ‰¾åˆ° user_idã€‚");
                        }
                    } catch (err) {
                        errorMessage.value = err.message || "åˆå§‹åŒ–ç”¨æˆ·ä¼šè¯æ—¶å‘ç”ŸæœªçŸ¥ç½‘ç»œé”™è¯¯ã€‚";
                    } finally {
                        isLoading.value = false;
                    }
                };

                onMounted(initializeUser);

                watch(currentView, (newView, oldView) => { 
                    switch(newView) {
                        case 'mainMenu': viewTitle.value = 'å–µå–µå­¦ä¹ å°åŠ©æ‰‹'; break;
                        case 'chapterOrderSelection': viewTitle.value = `æ¨¡å¼è®¾ç½® - ${modeDisplayName.value}`; break;
                        case 'quickReview': viewTitle.value = 'é€Ÿåˆ·æ¨¡å¼'; break;
                        case 'quizMode': viewTitle.value = 'ç­”é¢˜æ¨¡å¼'; break;
                        case 'incorrectReview': viewTitle.value = 'é”™é¢˜å›é¡¾'; break;
                        case 'resultsView': viewTitle.value = 'æœ¬è½®æ€»ç»“'; break;
                        case 'controlMode': viewTitle.value = 'æ§åˆ¶æ¨¡å¼'; break;
                        default: viewTitle.value = 'å–µå–µå­¦ä¹ å°åŠ©æ‰‹';
                    }
                    if (newView !== 'mainMenu' && !userId.value) { 
                        initializeUser();
                    }
                    errorMessage.value = ''; 
                    if (!isInQuestionView.value) { 
                        showJumpInput.value = false;
                    }
                });
                
                const navigateTo = (view) => {
                    currentView.value = view;
                };

                const goBackToMenu = () => {
                    resetModeState();
                    navigateTo('mainMenu');
                };

                const resetModeState = () => {
                    allModeQuestions.value = [];
                    currentQuestion.value = null;
                    currentQuestionIndex.value = -1;
                    totalQuestions.value = 0;
                    isQuizCompleted.value = false;
                    selectedAnswers.value = [];
                    feedbackMessage.value = '';
                    quizModeState.value = 'inProgress';
                    quizResults.value = { total_answered: 0, total_correct: 0 };
                    showJumpInput.value = false;
                    jumpToQuestionNumberInput.value = null;
                };
                
                const selectMode = (mode) => { 
                    if (!userId.value) {
                        errorMessage.value = "ç”¨æˆ·IDå°šæœªåˆå§‹åŒ–ï¼Œè¯·ç¨åæˆ–åˆ·æ–°é¡µé¢é‡è¯•ã€‚";
                        initializeUser(); 
                        return;
                    }
                    activeMode.value = mode; 
                    selectedChapters.value = []; 
                    selectedOrder.value = 'sequential'; 
                    
                    if (mode === 'quickReview') modeDisplayName.value = 'é€Ÿåˆ·æ¨¡å¼';
                    else if (mode === 'quizMode') modeDisplayName.value = 'ç­”é¢˜æ¨¡å¼';
                    else if (mode === 'incorrectReview') modeDisplayName.value = 'é”™é¢˜å›é¡¾';
                    
                    // For incorrectReview, we now also go to startSelectedMode,
                    // as it will call startIncorrectReview internally.
                    // navigateTo('chapterOrderSelection'); // Incorrect review does not use chapter selection
                     if (mode === 'incorrectReview') { 
                        startIncorrectReview(); 
                    } else {
                        navigateTo('chapterOrderSelection');
                    }
                };

                const toggleChapterSelection = (chapterValue) => {
                    if (chapterValue === 'all') {
                        if (selectedChapters.value.includes('all')) { 
                            selectedChapters.value = [];
                        } else { 
                            selectedChapters.value = availableChapters.value.map(c => c.value);
                        }
                    } else {
                        const index = selectedChapters.value.indexOf(chapterValue);
                        if (index > -1) {
                            selectedChapters.value.splice(index, 1);
                        } else {
                            selectedChapters.value.push(chapterValue);
                        }
                        const allIndividualChapters = availableChapters.value.filter(c => c.value !== 'all');
                        const allIndividualSelected = allIndividualChapters.every(c => selectedChapters.value.includes(c.value));
                        if (allIndividualSelected && !selectedChapters.value.includes('all')) {
                            selectedChapters.value.push('all');
                        } else if (!allIndividualSelected && selectedChapters.value.includes('all')) {
                            const allIndex = selectedChapters.value.indexOf('all');
                            if (allIndex > -1) selectedChapters.value.splice(allIndex, 1);
                        }
                    }
                };
                
                const startSelectedMode = async () => { 
                    if (!userId.value) {
                        errorMessage.value = "ç”¨æˆ·æœªåˆå§‹åŒ–ï¼Œè¯·åˆ·æ–°é¡µé¢æˆ–æ£€æŸ¥ç½‘ç»œè¿æ¥ã€‚";
                        await initializeUser(); 
                        if (!userId.value) return; 
                    }
                     // For incorrectReview, chapter selection is not applicable.
                    if (activeMode.value !== 'incorrectReview' && selectedChapters.value.length === 0) {
                        errorMessage.value = "è¯·è‡³å°‘é€‰æ‹©ä¸€ä¸ªç« èŠ‚ã€‚";
                        return;
                    }
                    isLoading.value = true;
                    resetModeState(); // Reset before starting a new mode

                    let url = '';
                    let requestBody = { user_id: userId.value };

                    if (activeMode.value === 'quickReview') {
                        url = `${API_BASE_URL}/api/review/start`;
                        requestBody.chapter_choice = selectedChapters.value.includes('all') ? ['all'] : selectedChapters.value.filter(c => c !== 'all');
                        requestBody.order_choice = selectedOrder.value;
                    } else if (activeMode.value === 'quizMode') {
                        url = `${API_BASE_URL}/api/quiz/start`;
                        requestBody.chapter_choice = selectedChapters.value.includes('all') ? ['all'] : selectedChapters.value.filter(c => c !== 'all');
                        requestBody.order_choice = selectedOrder.value;
                    } 
                    // incorrectReview is handled by its own start function
                     else {
                        errorMessage.value = "æœªçŸ¥çš„æ¨¡å¼: " + activeMode.value;
                        isLoading.value = false;
                        return;
                    }
                    
                    try {
                        const response = await fetch(url, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(requestBody)
                        });
                        if (!response.ok) {
                            const errBody = await response.text();
                            throw new Error(`å¼€å§‹${modeDisplayName.value}å¤±è´¥: ${response.statusText} (${response.status}) - ${errBody || '(æ— å“åº”ä½“)'}`);
                        }
                        const data = await response.json();
                        // EXPECTING 'questions' ARRAY FROM BACKEND NOW
                        if (data && data.questions && Array.isArray(data.questions)) { 
                            allModeQuestions.value = data.questions; 
                            totalQuestions.value = data.questions.length;
                            if (totalQuestions.value > 0) {
                                currentQuestionIndex.value = 0;
                                setCurrentQuestionFromIndex(); // This will set currentQuestion and reset states
                                isQuizCompleted.value = false; // Quiz starts, not completed
                                navigateTo(activeMode.value); 
                            } else {
                                errorMessage.value = data.message || "æ‰€é€‰èŒƒå›´æ²¡æœ‰é¢˜ç›®ã€‚";
                                navigateTo('chapterOrderSelection'); 
                            }
                        } else {
                             errorMessage.value = data.message || "æ²¡æœ‰è·å–åˆ°é¢˜ç›®æˆ–å“åº”æ ¼å¼ä¸æ­£ç¡® (æœŸæœ› 'questions' æ•°ç»„)ã€‚";
                             navigateTo('chapterOrderSelection');
                        }
                    } catch (err) {
                        errorMessage.value = err.message;
                    } finally {
                        isLoading.value = false;
                    }
                };

                const setCurrentQuestionFromIndex = () => {
                    if (currentQuestionIndex.value >= 0 && currentQuestionIndex.value < allModeQuestions.value.length) {
                        currentQuestion.value = allModeQuestions.value[currentQuestionIndex.value];
                        // Update display number based on the new index
                        if(currentQuestion.value) currentQuestion.value.display_number = currentQuestionIndex.value + 1;
                        
                        resetQuizStateForNewQuestion(); 
                        quizModeState.value = 'inProgress'; 
                        isQuizCompleted.value = false;
                    } else if (currentQuestionIndex.value >= allModeQuestions.value.length && allModeQuestions.value.length > 0) {
                        isQuizCompleted.value = true;
                        currentQuestion.value = null; 
                    } else {
                        isQuizCompleted.value = true;
                        currentQuestion.value = null;
                    }
                };

                const previousQuestion = () => {
                    if (currentQuestionIndex.value > 0) {
                        quizModeState.value = 'inProgress'; 
                        currentQuestionIndex.value--;
                        setCurrentQuestionFromIndex();
                    }
                };

                const toggleJumpInput = () => {
                    showJumpInput.value = !showJumpInput.value;
                    if (!showJumpInput.value) jumpToQuestionNumberInput.value = null;
                };

                const jumpToQuestion = () => {
                    const targetNum = parseInt(jumpToQuestionNumberInput.value, 10);
                    if (targetNum && targetNum >= 1 && targetNum <= totalQuestions.value) {
                        quizModeState.value = 'inProgress'; 
                        currentQuestionIndex.value = targetNum - 1; 
                        setCurrentQuestionFromIndex();
                        showJumpInput.value = false; 
                        jumpToQuestionNumberInput.value = null;
                    } else {
                        alert(`è¯·è¾“å…¥æœ‰æ•ˆçš„é¢˜å· (1-${totalQuestions.value})`);
                    }
                };
                
                const fetchNextQuestion = async () => { 
                    if (isQuizCompleted.value) {
                        navigateTo('resultsView');
                        return;
                    }
                    if (currentQuestionIndex.value < totalQuestions.value - 1) {
                        currentQuestionIndex.value++;
                        setCurrentQuestionFromIndex();
                    } else { 
                        isQuizCompleted.value = true;
                        if (quizModeState.value === 'showAnswer' || currentView.value === 'quickReview') { 
                           navigateTo('resultsView');
                        }
                    }
                };

                const submitAnswerForMode = async () => {
                    let userAnswerString = '';
                    if (currentQuestion.value?.question_type === 'å¤šé€‰é¢˜') {
                        userAnswerString = Array.isArray(selectedAnswers.value) ? [...selectedAnswers.value].sort().join('') : '';
                    } else { userAnswerString = selectedAnswers.value || ''; }

                    if ((currentQuestion.value?.question_type === 'å•é€‰é¢˜' && !userAnswerString) ||
                        (currentQuestion.value?.question_type === 'å¤šé€‰é¢˜' && userAnswerString.length === 0)) {
                        errorMessage.value = 'è¯·é€‰æ‹©ç­”æ¡ˆåå†æäº¤ï¼'; return;
                    }

                    const correctAnswerProcessed = (currentQuestion.value && typeof currentQuestion.value.correct_answer === 'string') 
                                                ? currentQuestion.value.correct_answer.split('').sort().join('') : '';
                    isCurrentAnswerCorrect.value = userAnswerString === correctAnswerProcessed;
                    feedbackMessage.value = isCurrentAnswerCorrect.value ? 'å›ç­”æ­£ç¡®ï¼ğŸ‘' : `å›ç­”é”™è¯¯ï¼æ­£ç¡®ç­”æ¡ˆæ˜¯ï¼š<strong>${currentQuestion.value.correct_answer}</strong>`;
                    quizModeState.value = 'showAnswer'; 
                    
                    isLoading.value = true; errorMessage.value = '';
                    let url = '';
                    if (activeMode.value === 'quizMode') url = `${API_BASE_URL}/api/quiz/submit_answer`;
                    else if (activeMode.value === 'incorrectReview') url = `${API_BASE_URL}/api/incorrect_questions/review/submit_answer`;
                    else { isLoading.value = false; return; }

                    try {
                        const requestBody = {
                            user_id: userId.value,
                            quiz_question_id: currentQuestion.value.quiz_question_id,
                            user_answer: userAnswerString,
                            was_correct: isCurrentAnswerCorrect.value 
                        };
                        const response = await fetch(url, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(requestBody) });
                        if (!response.ok) { 
                            const errBody = await response.text();
                            throw new Error(`æäº¤ç­”æ¡ˆè®°å½•å¤±è´¥: ${response.statusText} (${response.status}) - ${errBody || '(æ— å“åº”ä½“)'}`);
                        }
                        const data = await response.json(); 
                        
                        if (currentQuestionIndex.value >= totalQuestions.value - 1) {
                           isQuizCompleted.value = true;
                        } else {
                           isQuizCompleted.value = false; 
                        }
                        if (data.total_questions_answered && activeMode.value === 'quizMode') {
                             quizResults.value.total_answered = data.total_questions_answered;
                             if (isCurrentAnswerCorrect.value) { 
                                if (quizResults.value.total_correct === undefined) quizResults.value.total_correct = 0;
                                quizResults.value.total_correct++;
                             }
                        }

                    } catch (err) { errorMessage.value = err.message; } 
                    finally { isLoading.value = false; }
                };
                                
                const startIncorrectReview = async () => { 
                    if (!userId.value) { errorMessage.value = "ç”¨æˆ·æœªåˆå§‹åŒ–ï¼Œè¯·åˆ·æ–°é¡µé¢ã€‚"; await initializeUser(); if (!userId.value) return; }
                    isLoading.value = true;
                    resetModeState(); 
                    activeMode.value = 'incorrectReview'; 
                    viewTitle.value = 'é”™é¢˜å›é¡¾'; 
                    // quizModeState is reset in resetModeState to 'inProgress'

                    try {
                        const response = await fetch(`${API_BASE_URL}/api/incorrect_questions/review/start`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ user_id: userId.value })
                        });
                        if (!response.ok) { 
                            const errBody = await response.text();
                            throw new Error(`å¼€å§‹é”™é¢˜å›é¡¾å¤±è´¥: ${response.statusText} (${response.status}) - ${errBody || '(æ— å“åº”ä½“)'}`);
                         }
                        const data = await response.json();
                        // Backend now sends array of questions in 'questions' field
                        if (data && data.questions && Array.isArray(data.questions)) { 
                            allModeQuestions.value = data.questions; 
                            totalQuestions.value = data.questions.length;
                            if (totalQuestions.value > 0) {
                                currentQuestionIndex.value = 0;
                                setCurrentQuestionFromIndex();
                                isQuizCompleted.value = false;
                                navigateTo('incorrectReview'); 
                            } else {
                                errorMessage.value = data.message || "é”™é¢˜ç°¿æ˜¯ç©ºçš„ï¼";
                                navigateTo('mainMenu');
                            }
                        } else { 
                            errorMessage.value = data.message || "é”™é¢˜ç°¿æ˜¯ç©ºçš„æˆ–æ— æ³•åŠ è½½ã€‚";
                            navigateTo('mainMenu');
                        }
                    } catch (err) { 
                        errorMessage.value = err.message;
                    } 
                    finally { isLoading.value = false; }
                };
                const confirmClearUserData = () => {
                    if (confirm("å–µå‘œï¼è­¦å‘Šï¼šæ­¤æ“ä½œå°†é‡ç½®æ‚¨æ‰€æœ‰çš„å¯¹é”™ç»Ÿè®¡å¹¶åˆ é™¤é”™é¢˜ç°¿ï¼Œæ•°æ®æ— æ³•æ¢å¤ï¼\nç¡®å®šè¦æ¸…ç†å—ï¼Ÿ")) {
                        clearUserData();
                    }
                };
                const clearUserData = async () => { 
                    if (!userId.value) { errorMessage.value = "ç”¨æˆ·æœªåˆå§‹åŒ–ï¼Œæ— æ³•æ¸…ç†æ•°æ®ã€‚"; await initializeUser(); if (!userId.value) return; }
                    isLoading.value = true;
                    try {
                        const response = await fetch(`${API_BASE_URL}/api/user/data/clear`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ user_id: userId.value })
                        });
                        if (!response.ok) {
                             const errBody = await response.text();
                             throw new Error(`æ¸…ç†ç”¨æˆ·æ•°æ®å¤±è´¥: ${response.statusText} (${response.status}) - ${errBody || '(æ— å“åº”ä½“)'}`);
                        }
                        const data = await response.json();
                        alert(data.message || "ç”¨æˆ·æ•°æ®å·²æ¸…ç†ã€‚");
                        goBackToMenu(); 
                    } catch (err) { 
                        errorMessage.value = err.message;
                    } 
                    finally { isLoading.value = false; }
                };
                const sortedOptions = computed(() => {
                    if (currentQuestion.value && typeof currentQuestion.value.options === 'object' && currentQuestion.value.options !== null) {
                        try {
                            return Object.entries(currentQuestion.value.options)
                                .sort(([keyA], [keyB]) => keyA.localeCompare(keyB))
                                .reduce((obj, [key, value]) => { obj[key] = value; return obj; }, {});
                        } catch (e) { return {}; }
                    }
                    return {};
                });
                const formatQuestionText = (text) => text ? text.replace(/\n/g, '<br>') : '';
                const getOptionLabelClass = (optionKey) => {
                    const classes = [];
                    const userAnswersArray = Array.isArray(selectedAnswers.value) 
                                            ? selectedAnswers.value 
                                            : (selectedAnswers.value !== null && selectedAnswers.value !== undefined ? [String(selectedAnswers.value)] : []);
                                            
                    const correctAnswerString = (currentQuestion.value && typeof currentQuestion.value.correct_answer === 'string') 
                                            ? currentQuestion.value.correct_answer
                                            : '';
                    const correctAnswerKeys = correctAnswerString.split('');

                    if ((activeMode.value === 'quizMode' || activeMode.value === 'incorrectReview') && quizModeState.value === 'showAnswer') {
                        const isThisOptionActuallyCorrect = correctAnswerKeys.includes(optionKey);
                        const wasThisOptionSelectedByUser = userAnswersArray.includes(optionKey);

                        if (isThisOptionActuallyCorrect) { 
                            classes.push('correct'); 
                        } else if (wasThisOptionSelectedByUser) { 
                           classes.push('incorrect');
                        }
                    } else if ((activeMode.value === 'quizMode' || activeMode.value === 'incorrectReview') && quizModeState.value === 'inProgress') { 
                         if (userAnswersArray.includes(optionKey)) {
                            classes.push('selected');
                        }
                    }
                    return classes.join(' ');
                };
                const resetQuizStateForNewQuestion = () => {
                    if (currentQuestion.value) { 
                        selectedAnswers.value = currentQuestion.value.question_type === 'å•é€‰é¢˜' ? null : [];
                    } else {
                        selectedAnswers.value = null; 
                    }
                    feedbackMessage.value = '';
                    isCurrentAnswerCorrect.value = false; 
                };

                return {
                    isLoading, errorMessage, currentView, viewTitle, userId,
                    availableChapters, selectedChapters, selectedOrder,
                    activeMode, modeDisplayName,
                    allModeQuestions, currentQuestion, totalQuestions, isQuizCompleted, currentQuestionIndex,
                    selectedAnswers, quizModeState, feedbackMessage, isCurrentAnswerCorrect, quizResults,
                    isInQuestionView, showNextButton,
                    showJumpInput, jumpToQuestionNumberInput,
                    navigateTo, goBackToMenu, selectMode, toggleChapterSelection, startSelectedMode,
                    fetchNextQuestion, submitAnswerForMode, 
                    startIncorrectReview,
                    confirmClearUserData, clearUserData,
                    sortedOptions, formatQuestionText, getOptionLabelClass,
                    previousQuestion, toggleJumpInput, jumpToQuestion
                };
            }
        }).mount('#app');
    </script>
</body>
</html>
